{
  "language": "Solidity",
  "sources": {
    "contracts/v1/MentalPokerGameV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * This contract contain all the game logic\n */\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"./VerifierV1.sol\";\n\nenum GameStatus {\n    UNSET,\n    SET_AND_UNSTARTED,\n    STARTED,\n    ALL_SHUFFLED,\n    ALL_PROVIDED_DRAW_PROOF,\n    ALL_OPENED_CARD,\n    ENDED\n}\n\nenum PlayerStatus {\n    UNSHUFFLED,\n    SHUFFLED,\n    DRAWN_DARD_PROOF_PROVIDED,\n    CARD_OPENED,\n    ENDED\n}\n\nstruct Player {\n    address addr;\n    uint256 joinTimestamp;\n    PlayerStatus status;\n    string name;\n}\n\nstruct RoundInfo {\n    uint256 roundId;\n    // for fast look-up\n    mapping(address => Player) players;\n    // for iterate all the players\n    address[] playerAddresses;\n}\n\ncontract MentalPokerGame is Ownable {\n    // ========================== data fields ==========================\n    // containing all the data for all rounds\n    mapping(uint256 => RoundInfo) private rounds;\n\n    // current round\n    uint256 public currentRoundId;\n\n    uint256 public maxPlayerPerRound = 10;\n\n    // current game status\n    GameStatus public status;\n\n    // verifier address\n    VerifierV1 public verifier;\n\n    // ========================== Events ==========================\n    event VerifierSet(address indexed verifier);\n\n    event MaxPlayerPerRound(uint256 indexed count);\n\n    event PlayerRegistered(address indexed player, string indexed name, uint256 indexed roundId);\n\n    // anyone can call this to set up a new game\n    event GameStatusUpdated(uint256 indexed roundId, GameStatus indexed status);\n\n    // emit every time deck shuffled by player\n    event DeckShuffled(address indexed player, uint256 indexed roundId);\n\n    // emit every time set a new blocking player\n    event NextBlockingUser(\n        uint256 indexed playerIndex,\n        uint256 indexed roundId\n    );\n\n    // emit every time deck shuffled by player\n    event CardDrawnProofProvided(\n        address indexed player,\n        uint256 indexed roundId\n    );\n\n    // emit every time user submit their draw card proof and\n    event OpenCard(address indexed player, uint256 indexed roundId);\n\n    // ========================== modifiers ==========================\n    modifier onlyStatus(GameStatus status_) {\n        require(status == status_, \"wrong game status\");\n        _;\n    }\n\n    modifier onlyRound(uint256 roundId) {\n        require(currentRoundId == roundId, \"wrong round\");\n        _;\n    }\n\n    modifier checkPlayerExist() {\n        Player storage playerInfo = rounds[currentRoundId].players[msg.sender];\n        require(playerInfo.joinTimestamp != 0, \"you didn't join this round\");\n        _;\n    }\n\n    // ========================== public functions ==========================\n    constructor(VerifierV1 verifier_) {\n        verifier = verifier_;\n        emit VerifierSet(address(verifier));\n    }\n\n    function setMaxPlayerPerRound(uint256 count) external onlyOwner {\n        maxPlayerPerRound = count;\n        emit MaxPlayerPerRound(count);\n    }\n\n    function filteredPlayerStatusCount(uint256 roundId, PlayerStatus status_)\n        public\n        view\n        returns (uint256)\n    {\n        RoundInfo storage roundInfo = rounds[roundId];\n        address[] storage addrs = roundInfo.playerAddresses;\n        uint256 len = addrs.length;\n        uint256 count = 0;\n        for (uint256 i = 0; i < len; ++i) {\n            if (roundInfo.players[addrs[i]].status == status_) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    // Solidity: to export the dynamic fields which are behind the private access\n    function getGameInfo()\n        external\n        view\n        returns (uint256 roundId, Player[] memory playerInfos, GameStatus gameStatus)\n    {\n        roundId = currentRoundId;\n        address[] storage playerAddresses = rounds[roundId].playerAddresses;\n        gameStatus = status;\n        \n        playerInfos = new Player[](playerAddresses.length);\n\n        for (uint256 i = 0; i < playerAddresses.length; ++i) {\n            playerInfos[i] = rounds[roundId].players[playerAddresses[i]];\n        }\n    }\n\n    // return the next RoundId\n    function setupGame()\n        external\n        virtual\n        onlyStatus(GameStatus.UNSET)\n        returns (uint256)\n    {\n        require(verifier.setup(currentRoundId), \"setup failed\");\n        currentRoundId++;\n\n        _onToTheNextStatus();\n        return currentRoundId;\n    }\n\n    // player should call this function to join the game\n    function registerPlayer(string calldata name)\n        external\n        virtual\n        onlyStatus(GameStatus.SET_AND_UNSTARTED)\n    {\n        RoundInfo storage info = rounds[currentRoundId];\n        require(\n            info.playerAddresses.length <= maxPlayerPerRound,\n            \"reach player limit\"\n        );\n        require(\n            info.players[msg.sender].joinTimestamp == 0,\n            \"user registered!\"\n        );\n        Player memory player = Player({\n            addr: msg.sender,\n            name: name,\n            joinTimestamp: block.timestamp,\n            status: PlayerStatus.UNSHUFFLED\n        });\n        info.players[msg.sender] = player;\n        info.playerAddresses.push(msg.sender);\n        emit PlayerRegistered(msg.sender, name, currentRoundId);\n\n        // when reach to the player limit, go to the next status\n        if (info.playerAddresses.length == maxPlayerPerRound) {\n            _onToTheNextStatus();\n        }\n    }\n\n    // shuffle the deck\n    // proof: proof for going to the next deck\n    function shuffleDeck(ShuffleProof calldata proof)\n        external\n        onlyStatus(GameStatus.STARTED)\n        checkPlayerExist\n    {\n        RoundInfo storage roundInfo = rounds[currentRoundId];\n        Player storage playerInfo = roundInfo.players[msg.sender];\n        uint256 playerCount = roundInfo.playerAddresses.length;\n\n        require(\n            playerInfo.status != PlayerStatus.SHUFFLED,\n            \"already shuffled!\"\n        );\n\n        // try to verify\n        require(\n            verifier.verifyShuffleAndSave(proof, currentRoundId),\n            \"shuffle verify failed\"\n        );\n\n        // verification passes, proof is saved in Verification contract, now modify game storage\n        playerInfo.status = PlayerStatus.SHUFFLED;\n        emit DeckShuffled(msg.sender, currentRoundId);\n\n        bool noBlocker = filteredPlayerStatusCount(\n            currentRoundId,\n            PlayerStatus.SHUFFLED\n        ) == playerCount;\n        if (noBlocker) {\n            _onToTheNextStatus();\n        }\n    }\n\n    // provide card proof for all the other players, so the target player can draw the card sometime later,\n    // like at the competiton stage. The orders of the proofs for each user should passed by `proofIndexes`\n    function batchProvideDrawCardProof(\n        DrawProof[] calldata proofs,\n        uint256[] memory proofIndexes\n    ) external onlyStatus(GameStatus.ALL_SHUFFLED) checkPlayerExist {\n        RoundInfo storage roundInfo = rounds[currentRoundId];\n        Player storage playerInfo = roundInfo.players[msg.sender];\n\n        address[] storage playerAddresses = roundInfo.playerAddresses;\n        uint256 playerCount = playerAddresses.length;\n\n        require(proofs.length == playerCount - 1, \"proof count != other player count\");\n        require(proofs.length == proofIndexes.length, \"proof count != index count\");\n\n        require(\n            playerInfo.status != PlayerStatus.DRAWN_DARD_PROOF_PROVIDED,\n            \"you have provided proofs\"\n        );\n\n        for (uint256 i = 0; i < proofs.length; ++i) {\n            require(\n                verifier.verifyDrawnAndSave(\n                    proofs[i],\n                    playerAddresses[proofIndexes[i]],\n                    currentRoundId\n                ),\n                \"draw proof verify failed\"\n            );\n        }\n\n        // change the player status\n        playerInfo.status = PlayerStatus.DRAWN_DARD_PROOF_PROVIDED;\n\n        // check if all users have shuffled\n        bool noBlocker = filteredPlayerStatusCount(\n            currentRoundId,\n            PlayerStatus.DRAWN_DARD_PROOF_PROVIDED\n        ) == playerCount;\n        // when all players have shuffled, move to the next status\n        if (noBlocker) {\n            _onToTheNextStatus();\n        }\n\n        emit CardDrawnProofProvided(msg.sender, currentRoundId);\n    }\n\n    // users must call this function to open card with their proofs and values\n    function openCard(DrawProof calldata proof)\n        external\n        onlyStatus(GameStatus.ALL_PROVIDED_DRAW_PROOF)\n        checkPlayerExist\n    {\n        RoundInfo storage roundInfo = rounds[currentRoundId];\n        Player storage playerInfo = roundInfo.players[msg.sender];\n        uint256 playerCount = roundInfo.playerAddresses.length;\n\n        require(\n            playerInfo.status != PlayerStatus.CARD_OPENED,\n            \"you have opened card\"\n        );\n\n        require(\n            verifier.verifyDrawnAndSave(\n                proof,\n                msg.sender, // proof himself\n                currentRoundId\n            ),\n            \"open card proof verify failed\"\n        );\n\n        playerInfo.status = PlayerStatus.CARD_OPENED;\n\n        bool noBlocker = filteredPlayerStatusCount(\n            currentRoundId,\n            PlayerStatus.CARD_OPENED\n        ) == playerCount;\n        if (noBlocker) {\n            _onToTheNextStatus();\n        }\n        emit OpenCard(msg.sender, currentRoundId);\n    }\n\n    // anyone can call this function to trigger the calculation and get\n    // the final winner\n    function compete()\n        external\n        view\n        onlyStatus(GameStatus.ALL_OPENED_CARD)\n        returns (uint256, address)\n    {\n        RoundInfo storage roundInfo = rounds[currentRoundId];\n        address[] storage playerAddresses = roundInfo.playerAddresses;\n        uint256 userCount = playerAddresses.length;\n        uint256 biggestCard = 0;\n        uint256 winnerIndex = 0;\n        for (uint256 i = 0; i < userCount; ++i) {\n            DrawProof memory proof = verifier.getDrawProof(\n                playerAddresses[i],\n                currentRoundId\n            );\n            if (biggestCard < proof.decryptedCard) {\n                biggestCard = proof.decryptedCard;\n                winnerIndex = i;\n            }\n        }\n        return (biggestCard, playerAddresses[winnerIndex]);\n    }\n\n    // ========================== internals ==========================\n    // shift game status to the next\n    function _onToTheNextStatus() internal {\n        uint256 nextStatus = uint256(status) + 1;\n        // when the status reach the end, there is no way for this game to be replayed\n        require(nextStatus <= uint256(GameStatus.ENDED), \"game already ended\");\n        _updateGameStatus(GameStatus(nextStatus));\n    }\n\n    function _updateGameStatus(GameStatus status_) internal {\n        status = status_;\n        emit GameStatusUpdated(currentRoundId, status_);\n    }\n}\n"
    },
    "contracts/v1/VerifierV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * This contract contain all the cryptographic logic\n * todo: add onlyGame modifier for verification functions\n */\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nstruct Deck {\n    uint256[52] cards;\n}\n\nstruct ShuffleProof {\n    uint256[2] proof;\n    Deck nextDeck;\n}\n\nstruct DrawProof {\n    uint256[2] proof;\n    uint256 originalCard;\n    uint256 decryptedCard;\n}\n\ncontract VerifierV1 is Ownable {\n    // ========================== data fields ==========================\n    uint256 public constant TOTAL_CARD_NUMBER = 52;\n    // key: roundId\n    mapping(uint256 => ShuffleProof) public shuffleProofs;\n\n    // key: keccak(target + roundId)\n    mapping(bytes32 => DrawProof) public drawProofs;\n\n    address public game;\n\n    // ========================== Events ==========================\n\n    event Setup(uint256 indexed roundId);\n\n    event ShuffleProofVerified(address indexed sender, uint256 indexed roundId);\n\n    event DrawProofVerified(\n        address indexed sender,\n        address indexed target,\n        uint256 indexed roundId\n    );\n\n    // ========================== Modifier ==========================\n    modifier onlyGame() {\n        require(msg.sender == game, \"only game\");\n        _;\n    }\n\n    // ========================== public functions ==========================\n\n    function setGame(address game_) external onlyOwner {\n        game = game_;\n    }\n\n    function getShuffleProof(uint256 roundId)\n        public\n        view\n        returns (ShuffleProof memory)\n    {\n        return shuffleProofs[roundId];\n    }\n\n    function getDrawProof(address user, uint256 roundId)\n        public\n        view\n        returns (DrawProof memory)\n    {\n        bytes32 k = keccak256(abi.encode(user, roundId));\n        return drawProofs[k];\n    }\n\n    function setup(uint256 roundId) external onlyGame returns (bool) {\n        // set the initial proof and deck for this round\n        uint256[2] memory proof;\n        uint256[TOTAL_CARD_NUMBER] memory cards;\n        // cards are inited with 1,2,3,...\n        for (uint256 i = 0; i < TOTAL_CARD_NUMBER; i++) {\n            cards[i] = i + 1;\n        }\n        shuffleProofs[roundId] = ShuffleProof({\n            proof: proof,\n            nextDeck: Deck({cards: cards})\n        });\n\n        bytes32 k = keccak256(abi.encode(address(0), roundId));\n        drawProofs[k] = DrawProof({\n            proof: proof,\n            originalCard: 0,\n            decryptedCard: 0\n        });\n\n        return true;\n    }\n\n    // verify shuffle proof with the last saved deck, and going on\n    function verifyShuffleAndSave(ShuffleProof calldata proof, uint256 roundId)\n        external\n        onlyGame\n        returns (bool)\n    {\n        // todo: skipped the actual developing-expensive proof verification\n\n        // verifyShuffle(proof, last);\n\n        // save\n        shuffleProofs[roundId] = proof;\n        emit ShuffleProofVerified(msg.sender, roundId);\n        return true;\n    }\n\n    //\n    function verifyDrawnAndSave(\n        DrawProof calldata proof,\n        address target,\n        uint256 roundId\n    ) external onlyGame returns (bool) {\n        // todo: skipped the actual developing-expensive proof verification\n\n        // verifyDrawn(proof, last);\n\n        // save\n        bytes32 k = keccak256(abi.encode(target, roundId));\n        drawProofs[k] = proof;\n        emit DrawProofVerified(msg.sender, target, roundId);\n        return true;\n    }\n\n    // ========================== internals ==========================\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableMap.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToUintMap storage map,\n        uint256 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToUintMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key), errorMessage));\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        AddressToUintMap storage map,\n        address key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, key, errorMessage));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/v2/Verifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * This contract contain all the cryptographic logic\n */\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BoardManagerStorage.sol\";\n\nstruct ShuffleProof {\n    uint256[2] proof;\n    uint256[] deck;\n}\n\nstruct RevealProof {\n    uint256[2] proof;\n    uint256 card;\n}\n\ncontract Verifier is Ownable {\n    // ========================== data fields ==========================\n    ShuffleProof private shuffleProof;\n\n    // key: cardIndex\n    mapping(uint256 => RevealProof) public revealProofs;\n\n    address public game;\n\n    // ========================== Events ==========================\n\n    event Setup();\n\n    function getShuffleProof() public view returns (ShuffleProof memory) {\n        return shuffleProof;\n    }\n\n    function getRevealProof(uint256 cardIndex)\n        public\n        view\n        returns (RevealProof memory)\n    {\n        return revealProofs[cardIndex];\n    }\n\n    function setup(uint256[] calldata startingDeck) external returns (bool) {\n        // set the initial proof and deck for this round\n        uint256[2] memory proof = [uint256(0), uint256(0)];\n        shuffleProof = ShuffleProof({proof: proof, deck: startingDeck});\n\n        revealProofs[0] = RevealProof({proof: proof, card: 0});\n\n        return true;\n    }\n\n    // verify shuffle proof with the last saved deck, and going on\n    function verifyShuffleAndSave(ShuffleProof calldata proof)\n        external\n        returns (bool)\n    {\n        // verifyShuffleByCircomGeneratedFunction(proof, last);\n\n        // save\n        shuffleProof = proof;\n        return true;\n    }\n\n    //\n    function verifyRevealAndSave(RevealProof calldata proof)\n        external\n        returns (bool)\n    {\n        // verifyDrawnByCircomGeneratedFunction(proof, last);\n\n        // save\n        revealProofs[proof.card] = proof;\n        return true;\n    }\n\n    // ========================== internals ==========================\n}\n"
    },
    "contracts/v2/BoardManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nenum GameStage {\n    Uncreated,\n    GatheringPlayers,\n    Shuffle,\n    PreFlop, // in pre-flop, every gets 2 cards, and everyone must provide proofs\n    PreFlopBet,\n    Flop, // in flop, everyone must provide proofs for community cards\n    FlopBet,\n    Turn, // need reveal\n    TurnBet,\n    River, // need reveal\n    RiverBet,\n    PostRound, // waiting to announce winner\n    Ended\n}\n\nenum Rank {\n    Spades, \n    Hearts,\n    Diamonds,\n    Clubs\n}\n\n// example: \n// card value: 50\n// card info: rank: 50 / 13 = 3 (Clubs), value: 50 % 13 = 11 (2,3,4,5,6,7,8,9,j,>>Q<<,k,a)\nstruct CardInfo {\n    Rank rank;\n    uint256 value;\n}\n\n// the board state\nstruct Board {\n    // the current game status\n    GameStage stage;\n\n    // player infos\n    address[] playerAddresses;\n    uint256[][] playerHands;\n    uint256[] playerBets;\n    uint256[] playerStacks;\n    bool[] playersDoneForCurrentStage;\n    bool[] playerInPots;\n\n    uint256[] communityCards;\n\n    // next player index to player\n    uint256 nextPlayerToPlay;\n\n    uint256 dealerIndex;\n\n    uint256 bigBlindSize;\n\n    // the cards on the deck, from index 0 to len - 1 represent from bottom to the top\n    // so we can perform pop card easily \n    uint256[] deck;\n\n    // zero address before game ends\n    address winner;\n\n    // the required amount of players for this board\n    uint256 requiredPlayers;\n\n    // total stack in the pot\n    uint256 potSize;\n}\n"
    },
    "contracts/v2/IBoardManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BoardManagerStorage.sol\";\nimport \"./Verifier.sol\";\n\n\ninterface IBoardManager {\n    // ========================== Events ==========================\n    event BoardCreated(address indexed creator);\n    event BoardRefreshed(address indexed refresher);\n    event JoinedBoard(address indexed player);\n    event Checked(address indexed checker);\n    event Raised(address indexed raiser);\n    event Called(address indexed caller);\n    event Folded(address indexed folder);\n    event NextPlayer(uint256 indexed playerIndex);\n    event GameStageChanged(GameStage indexed stage);\n    event StackRequested(address indexed requester);\n\n    event DeckShuffled(address indexed player);\n    event RevealProofProvided(\n        address indexed sender,\n        uint256 indexed cardIndex);\n    event BatchRevealProofProvided(\n        address indexed sender,\n        uint256 indexed cardCount);\n\n    // ========================== Public ==========================\n    // create a board for a new game, reverts when\n    // - the current board is not ended yet\n    // - parameter checking fails\n    function createBoard(uint256 requiredPlayers, uint256 bigBlindSize) external;\n\n    // simply going to the next board, for dev purpose, anyone can call it\n    function refreshBoard() external;\n    \n    // player call this function to join the created board, reverts when\n    // - user has joined\n    // - board players reach the limit\n    function joinBoard() external returns (uint256 playerIndex);\n\n    // player call this function to check, reverts when\n    // - it's not the player's turn\n    // - player is not in the pot anymore\n    // - player can't check according to the game logic\n    // - game stage mismatch\n    function check() external;\n\n    // player call this function to raise, reverts when\n    // - it's not the player's turn\n    // - player is not in the pot anymore\n    // - player can't raise according to the game logic\n    // - game stage mismatch\n    function raise(uint256 amount) external;\n\n    // player call this function to call, reverts when\n    // - it's not the player's turn\n    // - player is not in the pot anymore\n    // - player can't call according to the game logic\n    // - game stage mismatch\n    function call(uint256 amount) external;\n\n    // player call this function to fold, reverts when\n    // - it's not the player's turn\n    // - player is not in the pot anymore\n    // - player can't fold according to the game logic\n    // - game stage mismatch\n    function fold() external;\n    \n\n    // everyone needs to shuffle the deck in order of joining, fails when\n    // - user who's not his turn calls this func\n    // - user shuffle twice\n    // - proof verification fails\n    function shuffleDeck(ShuffleProof calldata proof) external;\n\n    // everyone needs to provide the reveal proof to reveal a specific card of the deck, fails when\n    // - user who's not his turn calls this func\n    // - user provide for that card twice\n    // - proof verification fails\n    function provideRevealProof(RevealProof[] calldata proof) external;\n\n    // call this function the contract will calculate the hands of all players and save the winner\n    // also transfers all the bets on the table to the winner\n    function announceWinner() external returns (address winner, uint256 highestScore);\n\n    // dev purpose, request test stack for playing, will send 1000 stack to the called\n    function requestStack() external;\n\n    // ========================== View functions ==========================\n    function getShuffleProof() external view returns (ShuffleProof memory);\n    function getRevealProofs(uint256[] memory cardIndexes) external view returns (RevealProof[] memory);\n\n    function canCall(address player, uint256 amount) external view returns (bool);\n    function canRaise(address player, uint256 amount) external view returns (bool);  \n    function canCheck(address player) external view returns (bool);  \n    function canFold(address player) external view returns (bool);\n    \n    function amountToCall() external view returns (uint256);  \n    function smallBlindSize() external view returns (uint256);\n}\n"
    },
    "contracts/v2/BoardManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BoardManagerStorage.sol\";\nimport \"./IBoardManager.sol\";\nimport \"./Verifier.sol\";\nimport \"./GameUtils.sol\";\n\nenum BetType {\n    Call,\n    Fold,\n    Raise,\n    Check\n}\n\ncontract BoardManager is Ownable, IBoardManager, GameUtils {\n    // the current board data\n    // Solidity: it's have to be private to expose the dynamic members with a view function\n    Board board;\n\n    // mapping player address -> player index of joining\n    mapping(address => uint256) playerIndexesMap;\n\n    // mapping player address -> player in pot status\n    mapping(address => bool) playerInPotsMap;\n\n    bool public globalPaused;\n\n    address public verifier;\n\n    uint256 public immutable MIN_BIG_BLIND_SIZE = 10;\n    uint256 public immutable MIN_PLAYERS = 3;\n\n    // ========================= Modiftiers =============================\n    modifier onlyGameStages(GameStage stage) {\n        require(stage == board.stage, \"invalid game stage\");\n        _;\n    }\n\n    modifier checkExist() {\n        require(playerInPotsMap[msg.sender], \"player not joined\");\n        _;\n    }\n\n    modifier checkTurn() {\n        require(\n            board.nextPlayerToPlay == playerIndexesMap[msg.sender],\n            \"not your turn\"\n        );\n        _;\n    }\n    \n    // ====================================================================\n    // ========================= Public functions =========================\n    // these public functions are intended to be interacted with end users\n    // ====================================================================\n    constructor(address verifier_) {\n        require(verifier_ != address(0), \"zero address verifier\");\n        verifier = verifier_;\n    }\n\n    // we can't export dynamic mappings, so it's a workaround\n    function getBoard() public view returns (Board memory) {\n        return board;\n    }\n\n    function createBoard(uint256 requiredPlayers, uint256 bigBlindSize)\n        external\n        override\n        onlyGameStages(GameStage.Uncreated)\n    {\n        require(\n            requiredPlayers >= MIN_PLAYERS &&\n                bigBlindSize >= MIN_BIG_BLIND_SIZE,\n            \"required players >= 3 && big blind size >= 10\"\n        );\n\n        // create board, stage is already created\n        refreshBoard();\n        board.requiredPlayers = requiredPlayers;\n        board.bigBlindSize = bigBlindSize;\n        emit BoardCreated(msg.sender);\n    }\n\n    function refreshBoard() public override {\n        _clearMappings();\n        uint256[] memory cards = createInitialCards();\n        board.stage = GameStage.GatheringPlayers;\n        board.playerAddresses = new address[](0);\n        board.playerHands = new uint256[][](0);\n        board.playerBets = new uint256[](0);\n        board.playerStacks = new uint256[](0);\n        board.playerInPots = new bool[](0);\n        board.communityCards = new uint256[](0);\n        board.deck = cards;\n        board.winner = address(0);\n        board.potSize = 0;\n\n        // we don't set dealer index and next player index till we done player gathering\n\n        emit BoardRefreshed(msg.sender);\n    }\n\n    function joinBoard()\n        external\n        override\n        onlyGameStages(GameStage.GatheringPlayers)\n        returns (uint256)\n    {\n        require(!playerInPotsMap[msg.sender], \"already joined\");\n\n        uint256[] memory initialHand = new uint256[](0);\n        board.playerAddresses.push(msg.sender);\n        board.playerHands.push(initialHand);\n        board.playerBets.push(0);\n        board.playerStacks.push(0);\n        board.playersDoneForCurrentStage.push(true);\n        board.playerInPots.push(true);\n\n         // set flag\n        playerInPotsMap[msg.sender] = true;\n        playerIndexesMap[msg.sender] = board.playerAddresses.length - 1;\n\n        // when enough players are there, let's go\n        if (board.playerAddresses.length == board.requiredPlayers) {\n            board.stage = GameStage.Shuffle;\n            // dealer index is always the last joined player\n            board.dealerIndex = board.playerAddresses.length - 1;\n            // next player to play is 1 ahead of dealer index, which is 0\n            board.nextPlayerToPlay = 0;\n        }\n\n        emit JoinedBoard(msg.sender);\n\n        // return the index\n        return board.playerAddresses.length - 1;\n    }\n\n    function check() external override {\n        _performBet(BetType.Check);\n    }\n\n    function call(uint256 amount) external override {\n        _performBetWithAmount(BetType.Call, amount);\n    }\n\n    function raise(uint256 amount) external override {\n        _performBetWithAmount(BetType.Raise, amount);\n    }\n\n    function fold() external override {\n        _performBet(BetType.Fold);\n    }\n\n    function shuffleDeck(ShuffleProof calldata proof)\n        external\n        override\n        onlyGameStages(GameStage.Shuffle)\n        checkTurn\n        checkExist\n    {\n        require(verifier != address(0), \"empty verifier\");\n        require(\n            Verifier(verifier).verifyShuffleAndSave(proof),\n            \"verification failed\"\n        );\n\n        emit DeckShuffled(msg.sender);\n        _moveToTheNext();\n    }\n\n    function provideRevealProof(RevealProof[] calldata proofs)\n        external\n        override\n        checkExist\n        checkTurn\n    {\n        // needs provide proofs in preflop and flop round\n        require(isRevealRound(), \"cannot reveal proof\");\n        require(proofs.length > 0, \"empty proofs\");\n        for (uint256 i = 0; i < proofs.length; ++i) {\n            _provideRevealProof(proofs[i]);\n        }\n        emit BatchRevealProofProvided(msg.sender, proofs.length);\n        _moveToTheNext();\n    }\n\n    // extremely simplfied version of competing\n    function announceWinner()\n        external\n        override\n        onlyGameStages(GameStage.PostRound)\n        returns (address winner, uint256 highestScore)\n    {\n        for (uint256 i = 0; i < board.playerAddresses.length; ++i) {\n            uint256 score = 0;\n            uint256[] storage cards = board.playerHands[i];\n            for (uint256 j = 0; j < cards.length; ++j) {\n                score += cards[j];\n            }\n            if (highestScore < score) {\n                highestScore = score;\n                winner = board.playerAddresses[i];\n            }\n        }\n        // save winner\n        board.winner = winner;\n    }\n\n    function requestStack() external override checkExist {\n        uint256 playerIndex = playerIndexesMap[msg.sender];\n        board.playerStacks[playerIndex] += 1000;\n        emit StackRequested(msg.sender);\n    }\n\n    // ====================================================================\n    // ========================== View functions ==========================\n    // ====================================================================\n    function getShuffleProof()\n        public\n        view\n        override\n        returns (ShuffleProof memory)\n    {\n        return Verifier(verifier).getShuffleProof();\n    }\n\n    function getRevealProofs(uint256[] memory cardIndexes)\n        public\n        view\n        override\n        returns (RevealProof[] memory proofs)\n    {\n        require(cardIndexes.length > 0, \"\");\n        proofs = new RevealProof[](cardIndexes.length);\n        for (uint256 i = 0; i < cardIndexes.length; ++i) {\n            RevealProof memory proof = Verifier(verifier).getRevealProof(cardIndexes[i]);\n            proofs[i] = proof;\n        }\n    }\n\n    function isBetRound() public view returns (bool) {\n        return board.stage == GameStage.PreFlopBet\n            || board.stage == GameStage.FlopBet\n            || board.stage == GameStage.TurnBet\n            || board.stage == GameStage.RiverBet;\n    }\n\n    function isRevealRound() public view returns (bool) {\n        return board.stage == GameStage.PreFlop \n            || board.stage == GameStage.Flop \n            || board.stage == GameStage.Turn \n            || board.stage == GameStage.River\n            // in the post round, everyone needs to provide proof to open the card\n            || board.stage == GameStage.PostRound;\n    }\n\n    function canCall(address player, uint256 amount)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return isBetRound() &&\n            board.nextPlayerToPlay == playerIndexesMap[player] &&\n            playerInPotsMap[player];\n        // todo: && betAmount > lastBetAmount\n    }\n\n    function canCheck(address player) public view override returns (bool) {\n        return isBetRound() &&\n            board.nextPlayerToPlay == playerIndexesMap[player] &&\n            playerInPotsMap[player];\n        // && nobodyBet()\n    }\n\n    function canRaise(address player, uint256 amount)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return isBetRound() &&\n            board.nextPlayerToPlay == playerIndexesMap[player] &&\n            playerInPotsMap[player];\n        // todo: && betAmount > lastBetAmount\n    }\n\n    function canFold(address player) public view override returns (bool) {\n        return isBetRound() &&\n            board.nextPlayerToPlay == playerIndexesMap[player] &&\n            playerInPotsMap[player];\n    }\n\n    // todo\n    function amountToCall() public view override returns (uint256) {}\n\n    function smallBlindSize() public view override returns (uint256) {\n        return board.bigBlindSize / 2;\n    }\n\n\n    // ====================================================================\n    // ========================= Internals functions ======================\n    // ====================================================================\n\n    function _moveToTheNext() internal returns (bool gameStageChanged) {\n        // if there is no players joined, like while creating board, we move to the next round\n        if (\n            board.playerAddresses.length > 0 &&\n            board.nextPlayerToPlay != board.dealerIndex\n        ) {\n            board.nextPlayerToPlay++;\n            // skip the users have fold\n            address nextPlayer = board.playerAddresses[board.nextPlayerToPlay];\n            if (!playerInPotsMap[nextPlayer]) {\n                return _moveToTheNext();\n            }\n            emit NextPlayer(board.nextPlayerToPlay);\n            return false;\n        }\n        uint256 nextStatus = uint256(board.stage) + 1;\n        // when the status reach the end, there is no way for this game to be replayed\n        require(\n            nextStatus <= uint256(GameStage.PostRound),\n            \"game already ended\"\n        );\n\n        // now it's another round\n        board.stage = GameStage(nextStatus);\n        board.nextPlayerToPlay = 0; // (board.dealerIndex + 1) % playerCount\n        emit GameStageChanged(GameStage(nextStatus));\n\n        // post round\n        _postRound();\n\n        return true;\n    }\n\n    // Do something right after the game stage updated\n    function _postRound() internal {\n        uint256 len = board.playerAddresses.length;\n        if (board.stage == GameStage.PreFlop) {\n            // now it's preflop, assign 2 cards to each players\n            for (uint256 i = 0; i < len; ++i) {\n                board.playerHands[i] = new uint256[](2);\n                board.playerHands[i][0] = i * 2;\n                board.playerHands[i][1] = i * 2 + 1;\n            }\n        } else if (board.stage == GameStage.Flop) {\n            // now it's flop, assign 3 cards to community deck\n            board.communityCards = new uint256[](3);\n            board.communityCards[0] = len * 2;\n            board.communityCards[1] = len * 2 + 1;\n            board.communityCards[2] = len * 2 + 2;\n        }\n        else if (board.stage == GameStage.Turn) {\n            // now it's turn, assign 1 card to community deck\n            board.communityCards.push(len * 2 + 3);\n        }\n        else if (board.stage == GameStage.River) {\n            // now it's river, assign 1 card to community deck\n            board.communityCards.push(len * 2 + 4);\n        }\n        else if (board.stage == GameStage.Ended) {\n            _saveWinner();\n        }\n    }\n\n    function _performBetWithAmount(BetType betType, uint256 amount)\n        internal\n        checkExist\n        checkTurn\n    {\n        require(isBetRound(), \"can't bet now\");\n        uint256 playerIndex = playerIndexesMap[msg.sender];\n\n        if (betType == BetType.Call) {\n            require(canCall(msg.sender, amount), \"cannot call\");\n            require(\n                board.playerStacks[playerIndex] >= amount,\n                \"insufficient amount\"\n            );\n            board.playerStacks[playerIndex] -= amount;\n            board.playerBets[playerIndex] += amount;\n            board.potSize += amount;\n        } else if (betType == BetType.Raise) {\n            require(canRaise(msg.sender, amount), \"cannot raise\");\n            board.playerStacks[playerIndex] -= amount;\n            board.playerBets[playerIndex] += amount;\n            board.potSize += amount;\n        } else if (betType == BetType.Check) {\n            require(canCheck(msg.sender), \"cannot raise\");\n            // nothing happens when check\n        } else if (betType == BetType.Fold) {\n            require(canFold(msg.sender), \"cannot fold\");\n            playerInPotsMap[msg.sender] = false;\n            board.playerInPots[playerIndex] = false;\n            if(_tryAnnounceWinnerDirectly()) {\n                return;\n            }\n        }\n        // play is done for this round\n        board.playersDoneForCurrentStage[playerIndex] = true;\n        _moveToTheNext();\n    }\n\n    function _performBet(BetType betType) internal {\n        _performBetWithAmount(betType, 0);\n    }\n\n    function _provideRevealProof(RevealProof calldata proof) internal {\n        require(verifier != address(0), \"empty verifier\");\n        require(\n            Verifier(verifier).verifyRevealAndSave(proof),\n            \"verification failed\"\n        );\n    }\n\n    function _clearMappings() internal {\n        address[] storage addrs = board.playerAddresses;\n        for (uint256 i = 0; i < addrs.length; ++i) {\n            delete playerInPotsMap[addrs[i]];\n            delete playerIndexesMap[addrs[i]];\n        }\n    }\n\n    // if there is only one player left, announce winner directly\n    function _tryAnnounceWinnerDirectly() internal returns (bool hasWinner) {\n        uint256 stillInPot;\n        uint256 winnerIndex;\n        for (uint256 i = 0; i < board.playerInPots.length; ++i) {\n            if(board.playerInPots[i]) {\n                stillInPot++;\n                winnerIndex = i;\n            }\n        }\n        if (stillInPot == 1) {\n            board.winner = board.playerAddresses[winnerIndex];\n            board.stage = GameStage.Ended;\n            board.playerStacks[winnerIndex] += board.potSize; \n            board.potSize = 0;\n            hasWinner = true;\n        }\n    }\n\n    function _saveWinner() internal {\n        uint highestScore;\n        for (uint256 i = 0; i < board.playerAddresses.length; ++i) {\n            if (!board.playerInPots[i]) {\n                continue;\n            }\n            uint256 score = 0;\n            uint256[] storage cards = board.playerHands[i];\n            for (uint256 j = 0; j < cards.length; ++j) {\n                score += cards[j];\n            }\n            if (highestScore < score) {\n                highestScore = score;\n                board.winner = board.playerAddresses[i];\n            }\n        }\n    }\n\n}\n\n"
    },
    "contracts/v2/GameUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BoardManagerStorage.sol\";\n\ncontract GameUtils {\n    uint256 public immutable CARD_NUM = 52;\n\n    function createInitialCards()\n        internal\n        pure\n        returns (uint256[] memory cards)\n    {\n        cards = new uint256[](CARD_NUM);\n        for (uint256 i = 0; i < CARD_NUM; ++i) {\n            cards[i] = i + 1;\n        }\n        return cards;\n    }\n\n    function getCardInfo(uint256 val) public pure returns (CardInfo memory) {\n        return CardInfo({rank: Rank(val / 13), value: val % 13});\n    }\n}\n"
    },
    "contracts/v2/ZKVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * This contract contain all the cryptographic logic\n */\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// todo: change to the actual ZKP verifier\ncontract ZKVerifier {\n    // ========================== data fields ==========================\n\n    // ========================== Events ==========================\n\n    // ========================== public functions ==========================\n    constructor() {}\n\n    // ========================== internals ==========================\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}
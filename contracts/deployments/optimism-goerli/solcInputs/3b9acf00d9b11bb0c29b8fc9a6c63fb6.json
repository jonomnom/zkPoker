{
  "language": "Solidity",
  "sources": {
    "contracts/v1/MentalPokerGameV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * This contract contain all the game logic\n */\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"./VerifierV1.sol\";\n\nenum GameStatus {\n    UNSET,\n    SET_AND_UNSTARTED,\n    STARTED,\n    ALL_SHUFFLED,\n    ALL_PROVIDED_DRAW_PROOF,\n    ALL_OPENED_CARD,\n    ENDED\n}\n\nenum PlayerStatus {\n    UNSHUFFLED,\n    SHUFFLED,\n    DRAWN_DARD_PROOF_PROVIDED,\n    CARD_OPENED,\n    ENDED\n}\n\nstruct Player {\n    address addr;\n    uint256 joinTimestamp;\n    PlayerStatus status;\n    string name;\n}\n\nstruct RoundInfo {\n    uint256 roundId;\n    // for fast look-up\n    mapping(address => Player) players;\n    // for iterate all the players\n    address[] playerAddresses;\n}\n\ncontract MentalPokerGame is Ownable {\n    // ========================== data fields ==========================\n    // containing all the data for all rounds\n    mapping(uint256 => RoundInfo) private rounds;\n\n    // current round\n    uint256 public currentRoundId;\n\n    uint256 public maxPlayerPerRound = 10;\n\n    // current game status\n    GameStatus public status;\n\n    // verifier address\n    VerifierV1 public verifier;\n\n    // ========================== Events ==========================\n    event VerifierSet(address indexed verifier);\n\n    event MaxPlayerPerRound(uint256 indexed count);\n\n    event PlayerRegistered(address indexed player, string indexed name, uint256 indexed roundId);\n\n    // anyone can call this to set up a new game\n    event GameStatusUpdated(uint256 indexed roundId, GameStatus indexed status);\n\n    // emit every time deck shuffled by player\n    event DeckShuffled(address indexed player, uint256 indexed roundId);\n\n    // emit every time set a new blocking player\n    event NextBlockingUser(\n        uint256 indexed playerIndex,\n        uint256 indexed roundId\n    );\n\n    // emit every time deck shuffled by player\n    event CardDrawnProofProvided(\n        address indexed player,\n        uint256 indexed roundId\n    );\n\n    // emit every time user submit their draw card proof and\n    event OpenCard(address indexed player, uint256 indexed roundId);\n\n    // ========================== modifiers ==========================\n    modifier onlyStatus(GameStatus status_) {\n        require(status == status_, \"wrong game status\");\n        _;\n    }\n\n    modifier onlyRound(uint256 roundId) {\n        require(currentRoundId == roundId, \"wrong round\");\n        _;\n    }\n\n    modifier checkPlayerExist() {\n        Player storage playerInfo = rounds[currentRoundId].players[msg.sender];\n        require(playerInfo.joinTimestamp != 0, \"you didn't join this round\");\n        _;\n    }\n\n    // ========================== public functions ==========================\n    constructor(VerifierV1 verifier_) {\n        verifier = verifier_;\n        emit VerifierSet(address(verifier));\n    }\n\n    function setMaxPlayerPerRound(uint256 count) external onlyOwner {\n        maxPlayerPerRound = count;\n        emit MaxPlayerPerRound(count);\n    }\n\n    function filteredPlayerStatusCount(uint256 roundId, PlayerStatus status_)\n        public\n        view\n        returns (uint256)\n    {\n        RoundInfo storage roundInfo = rounds[roundId];\n        address[] storage addrs = roundInfo.playerAddresses;\n        uint256 len = addrs.length;\n        uint256 count = 0;\n        for (uint256 i = 0; i < len; ++i) {\n            if (roundInfo.players[addrs[i]].status == status_) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    // Solidity: to export the dynamic fields which are behind the private access\n    function getGameInfo()\n        external\n        view\n        returns (uint256 roundId, Player[] memory playerInfos, GameStatus gameStatus)\n    {\n        roundId = currentRoundId;\n        address[] storage playerAddresses = rounds[roundId].playerAddresses;\n        gameStatus = status;\n        \n        playerInfos = new Player[](playerAddresses.length);\n\n        for (uint256 i = 0; i < playerAddresses.length; ++i) {\n            playerInfos[i] = rounds[roundId].players[playerAddresses[i]];\n        }\n    }\n\n    // return the next RoundId\n    function setupGame()\n        external\n        virtual\n        onlyStatus(GameStatus.UNSET)\n        returns (uint256)\n    {\n        require(verifier.setup(currentRoundId), \"setup failed\");\n        currentRoundId++;\n\n        _onToTheNextStatus();\n        return currentRoundId;\n    }\n\n    // player should call this function to join the game\n    function registerPlayer(string calldata name)\n        external\n        virtual\n        onlyStatus(GameStatus.SET_AND_UNSTARTED)\n    {\n        RoundInfo storage info = rounds[currentRoundId];\n        require(\n            info.playerAddresses.length <= maxPlayerPerRound,\n            \"reach player limit\"\n        );\n        require(\n            info.players[msg.sender].joinTimestamp == 0,\n            \"user registered!\"\n        );\n        Player memory player = Player({\n            addr: msg.sender,\n            name: name,\n            joinTimestamp: block.timestamp,\n            status: PlayerStatus.UNSHUFFLED\n        });\n        info.players[msg.sender] = player;\n        info.playerAddresses.push(msg.sender);\n        emit PlayerRegistered(msg.sender, name, currentRoundId);\n\n        // when reach to the player limit, go to the next status\n        if (info.playerAddresses.length == maxPlayerPerRound) {\n            _onToTheNextStatus();\n        }\n    }\n\n    // shuffle the deck\n    // proof: proof for going to the next deck\n    function shuffleDeck(ShuffleProof calldata proof)\n        external\n        onlyStatus(GameStatus.STARTED)\n        checkPlayerExist\n    {\n        RoundInfo storage roundInfo = rounds[currentRoundId];\n        Player storage playerInfo = roundInfo.players[msg.sender];\n        uint256 playerCount = roundInfo.playerAddresses.length;\n\n        require(\n            playerInfo.status != PlayerStatus.SHUFFLED,\n            \"already shuffled!\"\n        );\n\n        // try to verify\n        require(\n            verifier.verifyShuffleAndSave(proof, currentRoundId),\n            \"shuffle verify failed\"\n        );\n\n        // verification passes, proof is saved in Verification contract, now modify game storage\n        playerInfo.status = PlayerStatus.SHUFFLED;\n        emit DeckShuffled(msg.sender, currentRoundId);\n\n        bool noBlocker = filteredPlayerStatusCount(\n            currentRoundId,\n            PlayerStatus.SHUFFLED\n        ) == playerCount;\n        if (noBlocker) {\n            _onToTheNextStatus();\n        }\n    }\n\n    // provide card proof for all the other players, so the target player can draw the card sometime later,\n    // like at the competiton stage. The orders of the proofs for each user should passed by `proofIndexes`\n    function batchProvideDrawCardProof(\n        DrawProof[] calldata proofs,\n        uint256[] memory proofIndexes\n    ) external onlyStatus(GameStatus.ALL_SHUFFLED) checkPlayerExist {\n        RoundInfo storage roundInfo = rounds[currentRoundId];\n        Player storage playerInfo = roundInfo.players[msg.sender];\n\n        address[] storage playerAddresses = roundInfo.playerAddresses;\n        uint256 playerCount = playerAddresses.length;\n\n        require(proofs.length == playerCount - 1, \"proof count != other player count\");\n        require(proofs.length == proofIndexes.length, \"proof count != index count\");\n\n        require(\n            playerInfo.status != PlayerStatus.DRAWN_DARD_PROOF_PROVIDED,\n            \"you have provided proofs\"\n        );\n\n        for (uint256 i = 0; i < proofs.length; ++i) {\n            require(\n                verifier.verifyDrawnAndSave(\n                    proofs[i],\n                    playerAddresses[proofIndexes[i]],\n                    currentRoundId\n                ),\n                \"draw proof verify failed\"\n            );\n        }\n\n        // change the player status\n        playerInfo.status = PlayerStatus.DRAWN_DARD_PROOF_PROVIDED;\n\n        // check if all users have shuffled\n        bool noBlocker = filteredPlayerStatusCount(\n            currentRoundId,\n            PlayerStatus.DRAWN_DARD_PROOF_PROVIDED\n        ) == playerCount;\n        // when all players have shuffled, move to the next status\n        if (noBlocker) {\n            _onToTheNextStatus();\n        }\n\n        emit CardDrawnProofProvided(msg.sender, currentRoundId);\n    }\n\n    // users must call this function to open card with their proofs and values\n    function openCard(DrawProof calldata proof)\n        external\n        onlyStatus(GameStatus.ALL_PROVIDED_DRAW_PROOF)\n        checkPlayerExist\n    {\n        RoundInfo storage roundInfo = rounds[currentRoundId];\n        Player storage playerInfo = roundInfo.players[msg.sender];\n        uint256 playerCount = roundInfo.playerAddresses.length;\n\n        require(\n            playerInfo.status != PlayerStatus.CARD_OPENED,\n            \"you have opened card\"\n        );\n\n        require(\n            verifier.verifyDrawnAndSave(\n                proof,\n                msg.sender, // proof himself\n                currentRoundId\n            ),\n            \"open card proof verify failed\"\n        );\n\n        playerInfo.status = PlayerStatus.CARD_OPENED;\n\n        bool noBlocker = filteredPlayerStatusCount(\n            currentRoundId,\n            PlayerStatus.CARD_OPENED\n        ) == playerCount;\n        if (noBlocker) {\n            _onToTheNextStatus();\n        }\n        emit OpenCard(msg.sender, currentRoundId);\n    }\n\n    // anyone can call this function to trigger the calculation and get\n    // the final winner\n    function compete()\n        external\n        view\n        onlyStatus(GameStatus.ALL_OPENED_CARD)\n        returns (uint256, address)\n    {\n        RoundInfo storage roundInfo = rounds[currentRoundId];\n        address[] storage playerAddresses = roundInfo.playerAddresses;\n        uint256 userCount = playerAddresses.length;\n        uint256 biggestCard = 0;\n        uint256 winnerIndex = 0;\n        for (uint256 i = 0; i < userCount; ++i) {\n            DrawProof memory proof = verifier.getDrawProof(\n                playerAddresses[i],\n                currentRoundId\n            );\n            if (biggestCard < proof.decryptedCard) {\n                biggestCard = proof.decryptedCard;\n                winnerIndex = i;\n            }\n        }\n        return (biggestCard, playerAddresses[winnerIndex]);\n    }\n\n    // ========================== internals ==========================\n    // shift game status to the next\n    function _onToTheNextStatus() internal {\n        uint256 nextStatus = uint256(status) + 1;\n        // when the status reach the end, there is no way for this game to be replayed\n        require(nextStatus <= uint256(GameStatus.ENDED), \"game already ended\");\n        _updateGameStatus(GameStatus(nextStatus));\n    }\n\n    function _updateGameStatus(GameStatus status_) internal {\n        status = status_;\n        emit GameStatusUpdated(currentRoundId, status_);\n    }\n}\n"
    },
    "contracts/v1/VerifierV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * This contract contain all the cryptographic logic\n * todo: add onlyGame modifier for verification functions\n */\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nstruct Deck {\n    uint256[52] cards;\n}\n\nstruct ShuffleProof {\n    uint256[2] proof;\n    Deck nextDeck;\n}\n\nstruct DrawProof {\n    uint256[2] proof;\n    uint256 originalCard;\n    uint256 decryptedCard;\n}\n\ncontract VerifierV1 is Ownable {\n    // ========================== data fields ==========================\n    uint256 public constant TOTAL_CARD_NUMBER = 52;\n    // key: roundId\n    mapping(uint256 => ShuffleProof) public shuffleProofs;\n\n    // key: keccak(target + roundId)\n    mapping(bytes32 => DrawProof) public drawProofs;\n\n    address public game;\n\n    // ========================== Events ==========================\n\n    event Setup(uint256 indexed roundId);\n\n    event ShuffleProofVerified(address indexed sender, uint256 indexed roundId);\n\n    event DrawProofVerified(\n        address indexed sender,\n        address indexed target,\n        uint256 indexed roundId\n    );\n\n    // ========================== Modifier ==========================\n    modifier onlyGame() {\n        require(msg.sender == game, \"only game\");\n        _;\n    }\n\n    // ========================== public functions ==========================\n\n    function setGame(address game_) external onlyOwner {\n        game = game_;\n    }\n\n    function getShuffleProof(uint256 roundId)\n        public\n        view\n        returns (ShuffleProof memory)\n    {\n        return shuffleProofs[roundId];\n    }\n\n    function getDrawProof(address user, uint256 roundId)\n        public\n        view\n        returns (DrawProof memory)\n    {\n        bytes32 k = keccak256(abi.encode(user, roundId));\n        return drawProofs[k];\n    }\n\n    function setup(uint256 roundId) external onlyGame returns (bool) {\n        // set the initial proof and deck for this round\n        uint256[2] memory proof;\n        uint256[TOTAL_CARD_NUMBER] memory cards;\n        // cards are inited with 1,2,3,...\n        for (uint256 i = 0; i < TOTAL_CARD_NUMBER; i++) {\n            cards[i] = i + 1;\n        }\n        shuffleProofs[roundId] = ShuffleProof({\n            proof: proof,\n            nextDeck: Deck({cards: cards})\n        });\n\n        bytes32 k = keccak256(abi.encode(address(0), roundId));\n        drawProofs[k] = DrawProof({\n            proof: proof,\n            originalCard: 0,\n            decryptedCard: 0\n        });\n\n        return true;\n    }\n\n    // verify shuffle proof with the last saved deck, and going on\n    function verifyShuffleAndSave(ShuffleProof calldata proof, uint256 roundId)\n        external\n        onlyGame\n        returns (bool)\n    {\n        // todo: skipped the actual developing-expensive proof verification\n\n        // verifyShuffle(proof, last);\n\n        // save\n        shuffleProofs[roundId] = proof;\n        emit ShuffleProofVerified(msg.sender, roundId);\n        return true;\n    }\n\n    //\n    function verifyDrawnAndSave(\n        DrawProof calldata proof,\n        address target,\n        uint256 roundId\n    ) external onlyGame returns (bool) {\n        // todo: skipped the actual developing-expensive proof verification\n\n        // verifyDrawn(proof, last);\n\n        // save\n        bytes32 k = keccak256(abi.encode(target, roundId));\n        drawProofs[k] = proof;\n        emit DrawProofVerified(msg.sender, target, roundId);\n        return true;\n    }\n\n    // ========================== internals ==========================\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableMap.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToUintMap storage map,\n        uint256 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToUintMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key), errorMessage));\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        AddressToUintMap storage map,\n        address key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, key, errorMessage));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/v2/Verifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * This contract contain all the cryptographic logic\n */\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BoardManagerStorage.sol\";\n\n\nimport \"./encrypt_verifier.sol\";\nimport \"./decrypt_verifier.sol\";\ninterface IEncryptVerifier {\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[209] memory input\n    ) external view;\n}\n\ninterface IDEcryptVerifier {\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[4] memory input\n    ) external view;\n}\n\nstruct ShuffleProof {\n    uint256[8] proof;\n    uint256[104] deck;\n}\n\nstruct RevealProof {\n    uint256[8] proof;\n    // 1st is the card value, 2nd and 3rd is the Y, 4th is the personal public key.\n    uint256[4] card;\n}\n\ncontract Verifier is Ownable {\n    // ========================== data fields ==========================\n    ShuffleProof private shuffleProof;\n    uint pk;\n\n    // key: cardIndex\n    mapping(uint256 => RevealProof) revealProofs;\n\n    address public game;\n\n    // ========================== Events ==========================\n\n    event Setup();\n\n    IEncryptVerifier public encrypt_verifier;\n    IDEcryptVerifier public decrypt_verifier;\n\n    constructor(\n        IEncryptVerifier encrypt_verifier_, \n        IDEcryptVerifier decrypt_verifier_\n    ) {\n        encrypt_verifier = encrypt_verifier_;\n        decrypt_verifier = decrypt_verifier_;\n    }\n\n    function getShuffleProof() public view returns (ShuffleProof memory) {\n        return shuffleProof;\n    }\n\n    function getRevealProof(uint256 cardIndex)\n        public\n        view\n        returns (RevealProof memory)\n    {\n        return revealProofs[cardIndex];\n    }\n\n    function setupPK(uint256 pk_) external {\n        pk = pk_;\n    }\n\n    function setup(uint256[104] calldata startingDeck) external returns (bool) {\n        // set the initial proof and deck for this round\n        uint256[8] memory proof = [\n            uint256(0), uint256(0),\n            uint256(0), uint256(0),\n            uint256(0), uint256(0),\n            uint256(0), uint256(0)\n        ];\n        shuffleProof = ShuffleProof({proof: proof, deck: startingDeck});\n\n        //revealProofs[0] = RevealProof({proof: proof, card: [0, pk]);\n\n        return true;\n    }\n\n    // verify shuffle proof with the last saved deck, and going on\n    function verifyShuffleAndSave(ShuffleProof calldata proof)\n        external\n        returns (bool)\n    {\n        uint[209] memory input;\n        for (uint i = 0; i < 104; i++) {\n            input[i] = proof.deck[i];\n        }\n\n        for (uint i = 0; i < 104; i++) {\n            input[i + 104] = shuffleProof.deck[i];\n        }\n\n        input[208] = pk;\n\n        encrypt_verifier.verifyProof(\n            [proof.proof[0], proof.proof[1]],\n            [[proof.proof[2], proof.proof[3]], [proof.proof[4], proof.proof[5]]],\n            [proof.proof[6], proof.proof[7]],\n            input\n        );\n\n        // save\n        shuffleProof = proof;\n        return true;\n    }\n\n    //\n    function verifyRevealAndSave(\n        uint256 cardStartIndex,\n        RevealProof calldata proof)\n        external\n        returns (bool)\n    {\n       decrypt_verifier.verifyProof(\n            [proof.proof[0], proof.proof[1]],\n            [[proof.proof[2], proof.proof[3]], [proof.proof[4], proof.proof[5]]],\n            [proof.proof[6], proof.proof[7]],\n            proof.card\n        );\n\n        revealProofs[cardStartIndex] = proof;\n        shuffleProof.deck[cardStartIndex] = proof.card[0];\n        return true;\n    }\n\n    // ========================== internals ==========================\n}\n"
    },
    "contracts/v2/BoardManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nenum GameStage {\n    Uncreated,\n    GatheringPlayers,\n    Shuffle,\n    PreFlop, // in pre-flop, every gets 2 cards, and everyone must provide proofs\n    PreFlopBet,\n    Flop, // in flop, everyone must provide proofs for community cards\n    FlopBet,\n    Turn, // need reveal\n    TurnBet,\n    River, // need reveal\n    RiverBet,\n    PostRound, // waiting to announce winner\n    Ended\n}\n\nenum Rank {\n    Spades, \n    Hearts,\n    Diamonds,\n    Clubs\n}\n\n// example: \n// card value: 50\n// card info: rank: 50 / 13 = 3 (Clubs), value: 50 % 13 = 11 (2,3,4,5,6,7,8,9,j,>>Q<<,k,a)\nstruct CardInfo {\n    Rank rank;\n    uint256 value;\n}\n\n// the board state\nstruct Board {\n    // the current game status\n    GameStage stage;\n\n    // player infos\n    address[] playerAddresses;\n    uint256[][] playerHands;\n    uint256[] playerBets;\n    uint256[] playerStacks;\n    bool[] playersDoneForCurrentStage;\n    bool[] playerInPots;\n\n    uint256[] communityCards;\n\n    // next player index to player\n    uint256 nextPlayerToPlay;\n\n    uint256 dealerIndex;\n\n    uint256 bigBlindSize;\n\n    // the cards on the deck, from index 0 to len - 1 represent from bottom to the top\n    // so we can perform pop card easily \n    uint256[] deck;\n\n    // zero address before game ends\n    address winner;\n\n    // the required amount of players for this board\n    uint256 requiredPlayers;\n\n    // total stack in the pot\n    uint256 potSize;\n}\n"
    },
    "contracts/v2/encrypt_verifier.sol": {
      "content": "//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// 2019 OKIMS\n//      ported to solidity 0.6\n//      fixed linter warnings\n//      added requiere error messages\n//\n// 2021 Remco Bloemen\n//       cleaned up code\n//       added InvalidProve() error\n//       always revert with InvalidProof() on invalid proof\n//       make encryptPairing strict\n//\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\nlibrary encryptPairing {\n  error InvalidProof();\n\n  // The prime q in the base field F_q for G1\n  uint256 constant BASE_MODULUS = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n  // The prime moludus of the scalar field of G1.\n  uint256 constant SCALAR_MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n  struct G1Point {\n    uint256 X;\n    uint256 Y;\n  }\n\n  // Encoding of field elements is: X[0] * z + X[1]\n  struct G2Point {\n    uint256[2] X;\n    uint256[2] Y;\n  }\n\n  /// @return the generator of G1\n  function P1() internal pure returns (G1Point memory) {\n    return G1Point(1, 2);\n  }\n\n  /// @return the generator of G2\n  function P2() internal pure returns (G2Point memory) {\n    return\n      G2Point(\n        [\n          11559732032986387107991004021392285783925812861821192530917403151452391805634,\n          10857046999023057135944570762232829481370756359578518086990519993285655852781\n        ],\n        [\n          4082367875863433681332203403145435568316851327593401208105741076214120093531,\n          8495653923123431417604973247489272438418190587263600148770280649306958101930\n        ]\n      );\n  }\n\n  /// @return r the negation of p, i.e. p.addition(p.negate()) should be zero.\n  function negate(G1Point memory p) internal pure returns (G1Point memory r) {\n    if (p.X == 0 && p.Y == 0) return G1Point(0, 0);\n    // Validate input or revert\n    if (p.X >= BASE_MODULUS || p.Y >= BASE_MODULUS) revert InvalidProof();\n    // We know p.Y > 0 and p.Y < BASE_MODULUS.\n    return G1Point(p.X, BASE_MODULUS - p.Y);\n  }\n\n  /// @return r the sum of two points of G1\n  function addition(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n    // By EIP-196 all input is validated to be less than the BASE_MODULUS and form points\n    // on the curve.\n    uint256[4] memory input;\n    input[0] = p1.X;\n    input[1] = p1.Y;\n    input[2] = p2.X;\n    input[3] = p2.Y;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n    }\n    if (!success) revert InvalidProof();\n  }\n\n  /// @return r the product of a point on G1 and a scalar, i.e.\n  /// p == p.scalar_mul(1) and p.addition(p) == p.scalar_mul(2) for all points p.\n  function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n    // By EIP-196 the values p.X and p.Y are verified to less than the BASE_MODULUS and\n    // form a valid point on the curve. But the scalar is not verified, so we do that explicitelly.\n    if (s >= SCALAR_MODULUS) revert InvalidProof();\n    uint256[3] memory input;\n    input[0] = p.X;\n    input[1] = p.Y;\n    input[2] = s;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n    }\n    if (!success) revert InvalidProof();\n  }\n\n  /// Asserts the pairing check\n  /// e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n  /// For example pairing([P1(), P1().negate()], [P2(), P2()]) should succeed\n  function pairingCheck(G1Point[] memory p1, G2Point[] memory p2) internal view {\n    // By EIP-197 all input is verified to be less than the BASE_MODULUS and form elements in their\n    // respective groups of the right order.\n    if (p1.length != p2.length) revert InvalidProof();\n    uint256 elements = p1.length;\n    uint256 inputSize = elements * 6;\n    uint256[] memory input = new uint256[](inputSize);\n    for (uint256 i = 0; i < elements; i++) {\n      input[i * 6 + 0] = p1[i].X;\n      input[i * 6 + 1] = p1[i].Y;\n      input[i * 6 + 2] = p2[i].X[0];\n      input[i * 6 + 3] = p2[i].X[1];\n      input[i * 6 + 4] = p2[i].Y[0];\n      input[i * 6 + 5] = p2[i].Y[1];\n    }\n    uint256[1] memory out;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n    }\n    if (!success || out[0] != 1) revert InvalidProof();\n    //if (!success) revert InvalidProof();\n  }\n}\n\n  struct VerifyingKey {\n    encryptPairing.G1Point alfa1;\n    encryptPairing.G2Point beta2;\n    encryptPairing.G2Point gamma2;\n    encryptPairing.G2Point delta2;\n    encryptPairing.G1Point[] IC;\n  }\n\nlibrary encryptKeyFirstHalf {\n  function verifyingKey() public pure returns (VerifyingKey memory vk) {\n    vk.alfa1 = encryptPairing.G1Point(\n      14378794661994809316668936077887579852844330409586136188493910229510707683568,\n      19007180918058273234125706522281291487787880146734549337345180962710738215208\n    );\n\n    vk.beta2 = encryptPairing.G2Point(\n      [5920706861016946300912146506670818945013737603659177373891149557636543490740, 12055325713222300848813253111985210672218263044214498326157766255150057128762],\n      [9700420230412290932994502491200547761155381189822684608735830492099336040170, 14277278647337675353039880797101698215986155900184787257566473040310971051502]\n    );\n\n    vk.gamma2 = encryptPairing.G2Point(\n      [11559732032986387107991004021392285783925812861821192530917403151452391805634, 10857046999023057135944570762232829481370756359578518086990519993285655852781],\n      [4082367875863433681332203403145435568316851327593401208105741076214120093531, 8495653923123431417604973247489272438418190587263600148770280649306958101930]\n    );\n\n    vk.delta2 = encryptPairing.G2Point(\n      [15416166490785395106276701378819499360808020701472216425918396243173800454713, 163449396295182247720023575482215853144909379359521393782489670998832185593],\n      [18050293563330412952915457967693723007653965703167951046542738888239878779321, 15463229414353227275274535145797178750698779279765271261521760282093356404415]\n    );\n\n    vk.IC = new encryptPairing.G1Point[](104);\n\n    \n      vk.IC[0] = encryptPairing.G1Point(\n        14592727775733262519998007842562394043305210694830141845877465535190185366716,\n        8516334610681481305419856826318787763618996543581856173319619908345541061517\n      );\n    \n      vk.IC[1] = encryptPairing.G1Point(\n        10805126477549885085176064279491885579489486964078777369672094005936564133822,\n        6123985083616755070146697035380998016657737514865996401108163326824100195595\n      );\n    \n      vk.IC[2] = encryptPairing.G1Point(\n        3686027374065919644898243231192453370069543382288042495312202519725886740574,\n        9495394099263831170906298129131430873528733649883722007752644644180645581975\n      );\n    \n      vk.IC[3] = encryptPairing.G1Point(\n        1236663899755434444548770717424268680980783805875281111856012035362016853487,\n        17963354510050717452033127132353961623161340386545253947615815604074287569358\n      );\n    \n      vk.IC[4] = encryptPairing.G1Point(\n        17552860724746907131755251600969479607419427877341161394016090628378967033251,\n        20760806642203932765514919656083358494307121745620572584957261284352889834185\n      );\n    \n      vk.IC[5] = encryptPairing.G1Point(\n        6342083480871303787726321084949171392582938341765810510103943036971446876470,\n        19844772878045546164041920980905655487285316034955219990730503325847917563793\n      );\n    \n      vk.IC[6] = encryptPairing.G1Point(\n        3533927074876648547797362902048808492300902627836448130970102380971392901631,\n        19495503670579781111463503450660275220746995532253162194053497542797808672787\n      );\n    \n      vk.IC[7] = encryptPairing.G1Point(\n        6529506370917939266705810122174187832319121168572402966512756990384493026244,\n        20780393905885120105038377621188885495292816365003406611374634093854929483067\n      );\n    \n      vk.IC[8] = encryptPairing.G1Point(\n        15230555264426458571189820793278510921578551846867928589984740331804270992234,\n        4226196862068629703835312975514673018909202265636276077442830081354029681154\n      );\n    \n      vk.IC[9] = encryptPairing.G1Point(\n        7193575343237360390856867088682389068275527256661899065176450593286985831092,\n        21697269425734114793105577435869406785743446674535118515449993247492909396937\n      );\n    \n      vk.IC[10] = encryptPairing.G1Point(\n        14098754775242329406365897925239645511611674371457005375160085785165414414189,\n        20150953984347934925947432274515841065114411550302657350648437543705608549916\n      );\n    \n      vk.IC[11] = encryptPairing.G1Point(\n        4427724200821055385122216825517845909008372073841279705769479000742271541836,\n        16116425037495582200791344480490750448850150581745537145742903600283545149920\n      );\n    \n      vk.IC[12] = encryptPairing.G1Point(\n        11320094397105990171005925014578224988931520352669097375384724082269029492949,\n        445601458796430688493533687898924777113505813375029022218136790769970015824\n      );\n    \n      vk.IC[13] = encryptPairing.G1Point(\n        11840725463379550639611679346522373697764179882780670730602538360814851391257,\n        8141864374068234392324923769398266386624472627740324801492911325358341134605\n      );\n    \n      vk.IC[14] = encryptPairing.G1Point(\n        14107900332550044175607299982124342730682267845524746349129703484801189053426,\n        1192602549044592599397236512482706868601546135462695228376865864198302358505\n      );\n    \n      vk.IC[15] = encryptPairing.G1Point(\n        21435937061458301835413742543313659338655762107146503332962312709377675547233,\n        2908758188677609637189897407417077192823024312421188856772890351569144302218\n      );\n    \n      vk.IC[16] = encryptPairing.G1Point(\n        2017463481830074077479594468228652781012773210870610350548779426758690314120,\n        2737973337799843510393244573056544536917977721511739143502024769208328967537\n      );\n    \n      vk.IC[17] = encryptPairing.G1Point(\n        18775844896041465299530739799494848369601569967461337810087931461082239594616,\n        9648529137416180986166777209898898175316042553006834797612373688997726828164\n      );\n    \n      vk.IC[18] = encryptPairing.G1Point(\n        5795886612624421049917942233976057226711403878349085446900491371758539009600,\n        3675713480715479515982381241821057633013419670099139419164648254585720718379\n      );\n    \n      vk.IC[19] = encryptPairing.G1Point(\n        3483456206450310233382387783632016495305478257020322110110215531351598508271,\n        7347880234761859779373402350343363457554226564822455985004646136115042324208\n      );\n    \n      vk.IC[20] = encryptPairing.G1Point(\n        2271154196542746858395693151233357057088453590665339761856084360374117904945,\n        8261887061501655554158848824879769530902935636951211432818735804521670184743\n      );\n    \n      vk.IC[21] = encryptPairing.G1Point(\n        18326180100834328755061819783709762097324197780899386136132525025219448871877,\n        19124777939645835400053790322211089821594004267238651620237626519322886698310\n      );\n    \n      vk.IC[22] = encryptPairing.G1Point(\n        6262698861420859777657387549039553242300042396292066496352874228809184936386,\n        8470358991284933857188980328451547825328321435597523904166856009782121013186\n      );\n    \n      vk.IC[23] = encryptPairing.G1Point(\n        17290071383001477493773187859201045615235250271643166485877474480350454793353,\n        11813526994456226869039731849414108644408555179350645888365687629082299273609\n      );\n    \n      vk.IC[24] = encryptPairing.G1Point(\n        8473177585333951093879101108166008963677284912083360341021470299207872544955,\n        6762208806740647908918315774609826869543256070502274359428319321181169820883\n      );\n    \n      vk.IC[25] = encryptPairing.G1Point(\n        15423537135989017677514937577988476625250288099125001283596068715347610271599,\n        821925959645403286791205242794051438611408679076769829754481786417239696260\n      );\n    \n      vk.IC[26] = encryptPairing.G1Point(\n        7719400255102484779439795353011029132491402439573598829070767333211249948423,\n        7371039177408436105661482664267174799260586925148400223883208445311733453107\n      );\n    \n      vk.IC[27] = encryptPairing.G1Point(\n        11419707184766790025977101270482190365229346600437560547303509722912751442897,\n        21518522312340965713182854081080044499960224247638955997650760442678632843162\n      );\n    \n      vk.IC[28] = encryptPairing.G1Point(\n        2625239762007889488522025959569643265266185659815709670734290876942706814806,\n        16033408547877588825794275150683480852045046335841463917448393937698859427013\n      );\n    \n      vk.IC[29] = encryptPairing.G1Point(\n        235197569812105149837172017118547747784918647598958710823160289258677263236,\n        17482028633607720847758669785173708204071208091466433964947134098209503515534\n      );\n    \n      vk.IC[30] = encryptPairing.G1Point(\n        3207923082866899175033030884729017018136622864940117006728761296070995023026,\n        2133429243885629192137228849628564317596488989104770481423046347802480469418\n      );\n    \n      vk.IC[31] = encryptPairing.G1Point(\n        6812793631843655167906864644163616860745687623847956980455148463987377936260,\n        3280476608452559038446556145942680482681617363576461588168955044651770938600\n      );\n    \n      vk.IC[32] = encryptPairing.G1Point(\n        19967925397803828221123333024102771566373474104427153457965315131583070965025,\n        13580115777136607681345463275992143768475779788323021710105043937027161840709\n      );\n    \n      vk.IC[33] = encryptPairing.G1Point(\n        21343478020453417367337456347841455130253757932365491605876876923567623303210,\n        5555321713397914197501750546870226689457324278446157319644129851976309114563\n      );\n    \n      vk.IC[34] = encryptPairing.G1Point(\n        5175614910221740454910904583812930124651938466027594464871729988478916843596,\n        19655528588043120101285110450240747225500002316132594349048576561728864221801\n      );\n    \n      vk.IC[35] = encryptPairing.G1Point(\n        16001524833978567998995077939976108181322341904263287749243804747226169608447,\n        5030281413860076419398512434974897371595713632341369144203243976761295617098\n      );\n    \n      vk.IC[36] = encryptPairing.G1Point(\n        14317131571521282205579917309604322836814115963212166402233247715185600027514,\n        19340690265242932721776630635149980153441860590794951953318323151120634721786\n      );\n    \n      vk.IC[37] = encryptPairing.G1Point(\n        4034764043533385580396788718873635722715935318647672753526863322478395973960,\n        2886160452034740026920318812357813704727104440996045304034650312110475668443\n      );\n    \n      vk.IC[38] = encryptPairing.G1Point(\n        19902127082756141778290304270845375930611804892378059422864299160391751366990,\n        99188875799934284911990718364207389151718780806198113576257633136864157494\n      );\n    \n      vk.IC[39] = encryptPairing.G1Point(\n        10643035622186123155387015148284702506043449742614176759017417964897501193386,\n        11322013303728391955213480670816849055755202090028364281570165111447178215760\n      );\n    \n      vk.IC[40] = encryptPairing.G1Point(\n        13596314928445532973721643286992420416631270380313528123141196454016962631956,\n        15424665761095802689047957680310726490740832627452359623056388630215940717536\n      );\n    \n      vk.IC[41] = encryptPairing.G1Point(\n        6408286156582307845341459668803353466141051492735632960388262500643948112132,\n        20776237620904246788847198443525229714563398744082083813343565173447411243400\n      );\n    \n      vk.IC[42] = encryptPairing.G1Point(\n        14862115877552714424866405808159117277846117648531071857256164862204035019493,\n        20904405759989598016090479126988716982989016684011983019251551470757889066704\n      );\n    \n      vk.IC[43] = encryptPairing.G1Point(\n        11808230995969390902350650287690092855225863102842877519657158100348312500292,\n        9131835233259870814914633764921584439572408468065824044221751012225433503667\n      );\n    \n      vk.IC[44] = encryptPairing.G1Point(\n        18674546621279050508217428948698280502967020071986671259832267118108276611016,\n        5754212094318872092589606649827831960428156506394611588582831338409036768971\n      );\n    \n      vk.IC[45] = encryptPairing.G1Point(\n        4423147508226858753015347004401234443829123924427281016959014140936524713809,\n        14827289558872894214590597361517691540825413130046754550885321882130466562898\n      );\n    \n      vk.IC[46] = encryptPairing.G1Point(\n        7055712613650167689317099611064588379368216497446158966460789633850624892791,\n        15205916915448946251847226717516147765419013215578211041626414047817529289512\n      );\n    \n      vk.IC[47] = encryptPairing.G1Point(\n        21284379041006093386957779823120452884236357431287707215172214830848888962757,\n        20941593556490895298963453930215607082030897869677544695344257023703090366251\n      );\n    \n      vk.IC[48] = encryptPairing.G1Point(\n        7187968933388884324554345425361655655332286100865578202729009462310399785664,\n        15331388868845104874493469449289300283245786039472822535139079567298483799016\n      );\n    \n      vk.IC[49] = encryptPairing.G1Point(\n        11088858797164998758945450815782319165952864801133524910522260482933889779521,\n        21249744507752241324783347119042293961177688214576229208780959444250619110471\n      );\n    \n      vk.IC[50] = encryptPairing.G1Point(\n        10786314908969564246818473221850397858440172693112286605865765455842551427924,\n        4443419412653532342859220687545477453332053037169781730643067713100674626360\n      );\n    \n      vk.IC[51] = encryptPairing.G1Point(\n        6983986715756363575212756886501020534168920247212932027296261286429247394911,\n        1424193511100838123477958906182308617999375663407962905818192321257792940725\n      );\n    \n      vk.IC[52] = encryptPairing.G1Point(\n        3650676417449067846986205681751087233844639774183242348595966662537795622452,\n        11822369973821733347605044376599582950752206917594358146545304181236267301588\n      );\n    \n      vk.IC[53] = encryptPairing.G1Point(\n        12060271643658631283129950823333337497828437032576293937306959349725268072732,\n        17382073355402307795681487502367673489045705588766000712393330950513974212147\n      );\n    \n      vk.IC[54] = encryptPairing.G1Point(\n        8901359503433915089781204674493673653132415352725093073159727562001731433368,\n        12358895924622215248664581227360407147175225059741965569398445892680006686830\n      );\n    \n      vk.IC[55] = encryptPairing.G1Point(\n        78762817052005148475557119791425667352254639313709313235172550239841497018,\n        19953082868265619658017013152462754022539806087569376931245790444221008042671\n      );\n    \n      vk.IC[56] = encryptPairing.G1Point(\n        5861801675337959266627977280547531691962743603633233740716811030645013750463,\n        584549086874697194244312251078152051104848535011241093336273350624682201124\n      );\n    \n      vk.IC[57] = encryptPairing.G1Point(\n        8332493441044995205606592034372470996564171010851565302551983895123573591918,\n        1367650294948199799510048672622835763480864205577898002785300172269045197528\n      );\n    \n      vk.IC[58] = encryptPairing.G1Point(\n        11879966425913905883517331492338438651525814953896456424487677648710404186724,\n        18740274001712633917855230972064136923067878108521963685707992600953884107630\n      );\n    \n      vk.IC[59] = encryptPairing.G1Point(\n        19723943865423209846739000079932163001332859111395042950062280514554826810331,\n        6795430942754205855962998384086843702256365191064844856656530011964227287806\n      );\n    \n      vk.IC[60] = encryptPairing.G1Point(\n        4430897792340736104401042996372525434683609849300635682866399959912599369317,\n        16334688315528525316771073086277872588541743840969570355699428310521344999334\n      );\n    \n      vk.IC[61] = encryptPairing.G1Point(\n        21007164995559009024471398981352962392416492561285761251370290785397225595957,\n        11672437384650218587180902727424041087087501859592340687380013374048072359958\n      );\n    \n      vk.IC[62] = encryptPairing.G1Point(\n        6774807365098388082431468614848035664564641492936613682687734183196530758983,\n        18515057948896988646867384333466502524501390203432968951171163129746066977740\n      );\n    \n      vk.IC[63] = encryptPairing.G1Point(\n        21354264777816122092923916809773494416440519507315650773469110020767391085693,\n        12928486359092386194593378961923530722669130130694595577878944096045679809832\n      );\n    \n      vk.IC[64] = encryptPairing.G1Point(\n        16204911443959801493190326532918388062578644431942446511765016795182962351613,\n        4152735663785768808615684987918861360052245384655284461045510385965987995495\n      );\n    \n      vk.IC[65] = encryptPairing.G1Point(\n        6188942348915625613066359134243994138440825238460704836139145005684927953402,\n        8233140870967856143437823111333787632532118704266585163880199025355234705373\n      );\n    \n      vk.IC[66] = encryptPairing.G1Point(\n        19626284806863454498186490054974860220281263693145418875710924234349016461549,\n        7111193807332430088233350412324387504256685007834085459812787411916936540531\n      );\n    \n      vk.IC[67] = encryptPairing.G1Point(\n        15970240461902222558805010216482156882256670502781958899269454754835580662139,\n        4934360400409902867687360269833129454874322786143232302734404128739788875089\n      );\n    \n      vk.IC[68] = encryptPairing.G1Point(\n        7169019016723699206734673584679234547375659135572063100962850956770653944875,\n        7368760365028610843052945281319485986083220093405382963826479228969034226787\n      );\n    \n      vk.IC[69] = encryptPairing.G1Point(\n        15932876827545835192805885765914475944547219221428641697467412724564402121408,\n        8329234192826868853241832795885181173945788907548243475692928186866897953540\n      );\n    \n      vk.IC[70] = encryptPairing.G1Point(\n        5921001623173257438819615675412368529718206190993422173513992532049468861157,\n        7110844431289299311171393261571808652352361127870787530622152020614628268647\n      );\n    \n      vk.IC[71] = encryptPairing.G1Point(\n        4600943458266749525920238572648069216171871321407650802034792323392165063665,\n        15826008989425229962318535499684661499009231472915808075056830090511608526478\n      );\n    \n      vk.IC[72] = encryptPairing.G1Point(\n        13068574748276003649454384647806515501148832236972945618201503188151860010970,\n        14691464400329334900872413066714719640543222830027391298459334062295810312330\n      );\n    \n      vk.IC[73] = encryptPairing.G1Point(\n        9396789976103152914379737603994400960701207465281205793788131313680289398157,\n        7174182847571322613055872614863563150948233580147685848194574433652838354784\n      );\n    \n      vk.IC[74] = encryptPairing.G1Point(\n        11539293459246324620206800792300063648639384352337331897602001210957793975543,\n        19787432931920238523947745183564669818705212224284541459443125836093327532554\n      );\n    \n      vk.IC[75] = encryptPairing.G1Point(\n        15080990737641815326921669894549567525590492561409057923611315487374098990023,\n        19858317306486872976991966323786835265479537379391880093595722343546732466915\n      );\n    \n      vk.IC[76] = encryptPairing.G1Point(\n        3584540728649842992174043263111814830363848163151093243926692582951459719082,\n        639257643616640250884926787342302819305364884792806243612384721559765504263\n      );\n    \n      vk.IC[77] = encryptPairing.G1Point(\n        4273241058190310796643999316382402752650071001496301711368730136597250298840,\n        19369321142790161733618046373183682310178655945018806057872741610380372452827\n      );\n    \n      vk.IC[78] = encryptPairing.G1Point(\n        272499841877690166576840558481600920856967565767432408172882063329839573281,\n        17921725769880795946605711378148237042208445859677237025714402011448763998251\n      );\n    \n      vk.IC[79] = encryptPairing.G1Point(\n        21721465111017321769830920393485089516764363533717217882697503355372111989088,\n        15341671821372685199984448074874897372211991096768906428104547357257172366627\n      );\n    \n      vk.IC[80] = encryptPairing.G1Point(\n        21768319318420986984531018788897774033372473270507301419646898728644768996751,\n        19544472155316731280937860644410361973181649931746582546359401265126921524852\n      );\n    \n      vk.IC[81] = encryptPairing.G1Point(\n        11079352023219504017374863003510165131795499075208564469090382026260635416447,\n        210648695442196307462428514997047551745773545472900105743575759407753682837\n      );\n    \n      vk.IC[82] = encryptPairing.G1Point(\n        16358825899671514762650034591817362521206620275156477096138224114003420428585,\n        3003054706801688450869090242731979376694271832103157082033166263097412013049\n      );\n    \n      vk.IC[83] = encryptPairing.G1Point(\n        20320980866069142452071742746289721607189572189703557923160979214318310494950,\n        18981556558254714810539878215105181680590735157643600062561896134619917686724\n      );\n    \n      vk.IC[84] = encryptPairing.G1Point(\n        21116060871833286236478147202582360715365174088469988336664706637381472128439,\n        7095982631271336663853751008959804661066795302248558656488461672040944209032\n      );\n    \n      vk.IC[85] = encryptPairing.G1Point(\n        16446089718099676813365301231032291382128348869187412090154137632640656703008,\n        18373343652688711936662350574868117966981079711419602404765053358241758204277\n      );\n    \n      vk.IC[86] = encryptPairing.G1Point(\n        2269214023714049907313091000901681947061091020717905036960672922762538112117,\n        12110022698799468317591046938543803902476695073491463486087257878724434327824\n      );\n    \n      vk.IC[87] = encryptPairing.G1Point(\n        17885767837306866608249337286245290609385762690125108824411172128063193807211,\n        8829784480628493241258666416794722978349649294567547873387748687165277559777\n      );\n    \n      vk.IC[88] = encryptPairing.G1Point(\n        10218689470749034835496971517047878923055871140573461901166504759903216344519,\n        13390587051111066470853184754112101323747574039949291309233674739531239781525\n      );\n    \n      vk.IC[89] = encryptPairing.G1Point(\n        19286208953893311262326460345551941281024068392610940500260811300261406674102,\n        17938604108642151734940284251406741554937831762410638858730073109376419879943\n      );\n    \n      vk.IC[90] = encryptPairing.G1Point(\n        3539762868537136405124279530211863984802804456936509332728846905466221241497,\n        18935243619428274906405782136948748724906542507707896532521863374659928462461\n      );\n    \n      vk.IC[91] = encryptPairing.G1Point(\n        3306573722266519317025782898165114313922492724417921620068555576309709911348,\n        458272975385361683867812583849145967603457956651334476457200352597644638723\n      );\n    \n      vk.IC[92] = encryptPairing.G1Point(\n        18525152771895395035846876226579142187512541853544192567547847673585017455031,\n        21059867567611660273299804517125971799761022325985241251360869259153865392222\n      );\n    \n      vk.IC[93] = encryptPairing.G1Point(\n        753153315949457372244801422754897538495755480182132887902068442847845734186,\n        17989775825350174722987066480224866248670738469945301096990333971582755345794\n      );\n    \n      vk.IC[94] = encryptPairing.G1Point(\n        16429838277767362986864868930272845566571137744420059103232463623360418529756,\n        18914148445199994482357040302032377476214149463830198108222527007673843856049\n      );\n    \n      vk.IC[95] = encryptPairing.G1Point(\n        3082802264337218435637908240298185076398652788859025201311276800747878229721,\n        7223254470795586304912156553007433004884806001438329369470741850197035882089\n      );\n    \n      vk.IC[96] = encryptPairing.G1Point(\n        12154291980291375215580708701580795787452057661798323503325611201924275398210,\n        5422816588602484833031951175918619249597894060396236293586624492959720265064\n      );\n    \n      vk.IC[97] = encryptPairing.G1Point(\n        8801682358769366940704340935211975674852289440901630293034680436267583475488,\n        1288430432637759639440732611549897651706018461785254153683050314802643842802\n      );\n    \n      vk.IC[98] = encryptPairing.G1Point(\n        21778949033853638296811015253740147586044172438064130491627355461942764550018,\n        13939650572101082001670661822457557589309458512681923054782440470752803461847\n      );\n    \n      vk.IC[99] = encryptPairing.G1Point(\n        2284757465065495943461937566384667294940215912191333887586823780719086861305,\n        15464262726499527705189075697500722484203305353221675768498737906446027534197\n      );\n    \n      vk.IC[100] = encryptPairing.G1Point(\n        21147610927872807704403092947448468143192317419686144859024280524312903567757,\n        17772190396543631789959257949427829936026259685257937607010092324492586255464\n      );\n    \n      vk.IC[101] = encryptPairing.G1Point(\n        20385314557372324264152761267033012343561212904977507062968109871005700418880,\n        9722510406540939537073933791642696541257246241443327460101218493760427833660\n      );\n    \n      vk.IC[102] = encryptPairing.G1Point(\n        20266300797648446923940870515381391801789628086949732566336921566513567286957,\n        12497236662813943375036297617634616380246240355783498701570104965345596931278\n      );\n    \n      vk.IC[103] = encryptPairing.G1Point(\n        18133830790226201543946340805907666844607481233037212668395969040315898651321,\n        11382866975236709480952558448775036371285051504259104863426225686370251888116\n      );\n    \n   \n  }\n\n}\n\nlibrary encryptKeySecondHalf {\n\n  function verifyingKey() public pure returns (VerifyingKey memory vk) {\n    vk.IC = new encryptPairing.G1Point[](210);\n      vk.IC[104] = encryptPairing.G1Point(\n        21323510843110474161288875565374584586603956720209998234901128544499577622046,\n        20430522108461987251920058992906310529743685940924016417033628707483282889512\n      );\n    \n      vk.IC[105] = encryptPairing.G1Point(\n        6497720137237237525061487326489667416527064448657396454232369242755448738272,\n        8361413934417462639763933102327867735440740313521226905203814836801837717288\n      );\n    \n      vk.IC[106] = encryptPairing.G1Point(\n        2839322325619902825099875280452182065164425408487637615267779917940714294033,\n        8559665848348054430333260557771861344916900745246164109509364706073632106086\n      );\n    \n      vk.IC[107] = encryptPairing.G1Point(\n        3637379476434176046283959865411631664695522657179649562928046905059942820928,\n        13905393848617410596321789221701564173207881878963042213680618213055046091893\n      );\n    \n      vk.IC[108] = encryptPairing.G1Point(\n        21714539525643515964916345627215003871274472023987649631322554011518144945004,\n        19622165495584042856177666280301135993457567447276917562817041143070373008899\n      );\n    \n      vk.IC[109] = encryptPairing.G1Point(\n        4588615366324889064479428653189211998355142723802105862381768655358368894975,\n        14336798481487057410408125731308212224441680514126573463281324400130422407578\n      );\n    \n      vk.IC[110] = encryptPairing.G1Point(\n        928027114539968520693294659252413283591411288095991249303815541579630690501,\n        8217194294342483687753277698208983636805528735721894875236431756986591780976\n      );\n    \n      vk.IC[111] = encryptPairing.G1Point(\n        13408672821862254000861332155009577546601197739716849973862176454510910763251,\n        20262628886256846888236176015467659412812847706935055673295001612355473648514\n      );\n    \n      vk.IC[112] = encryptPairing.G1Point(\n        12316164149782623461036675094418852000771054076492652165678775263894292952396,\n        12705956329018384864793534256888354536436259361485253019573500651986392364249\n      );\n    \n      vk.IC[113] = encryptPairing.G1Point(\n        6624566619179617148554181388881599955719777281797445032778336516695825118365,\n        17745785773832764337325572883242506216041495477150301048566890534950062698908\n      );\n    \n      vk.IC[114] = encryptPairing.G1Point(\n        20359084141577165831508264604072368466497634108122033005058873137704150394861,\n        6715451819382122414740042859371957758214280917861401516870109493077540652437\n      );\n    \n      vk.IC[115] = encryptPairing.G1Point(\n        11615304638921870474756683331797582028451562953362364512723627896419746825460,\n        20893899662546769613950494602007524621854436629744596727521068103554238084674\n      );\n    \n      vk.IC[116] = encryptPairing.G1Point(\n        3882054065150451821676196620786633651105500180483175175104128560208064339416,\n        11960429157011880935128221110766801609728859385294695018604042359093657934438\n      );\n    \n      vk.IC[117] = encryptPairing.G1Point(\n        8457452990939444971924686117953943319878718522958444166326719729038636762549,\n        5600009663433519654759420207242376965852316335747823027182742059461947808517\n      );\n    \n      vk.IC[118] = encryptPairing.G1Point(\n        20949992463711200249710884440277312724275103498376474686091291539037147067189,\n        15157143775932475382536467939303614720170233386819304763560512065576447674940\n      );\n    \n      vk.IC[119] = encryptPairing.G1Point(\n        1478920072850447549124265161007302216638705664894884727949229548545462715436,\n        13807652199881986017629781311223328682568418002423955368907580471590603400207\n      );\n    \n      vk.IC[120] = encryptPairing.G1Point(\n        1422008260060096352530933049707291438043703272964573483722981457576281583825,\n        1662117051146751833604750340996831162823052647928078777523546939196164480553\n      );\n    \n      vk.IC[121] = encryptPairing.G1Point(\n        18254030897803798521809027973488199378123956052221358696941351654327268309141,\n        5643558544176520758984974013254063045296607657258566058070613809147136657013\n      );\n    \n      vk.IC[122] = encryptPairing.G1Point(\n        6741177670979725744112950856251654765050874055408525466173245066673356428321,\n        19056776893262589159485033604784967595823828454413924502284626766977186379962\n      );\n    \n      vk.IC[123] = encryptPairing.G1Point(\n        19892589373704724484566284977208385804458920451023602463648553239914881210043,\n        4469356706727324737819724152071838430664127769335011616933027038371171249681\n      );\n    \n      vk.IC[124] = encryptPairing.G1Point(\n        21338653159054417694546282761506369589540267232985556106385507377102226487177,\n        1014206782250379799587947549473683564827507936919554987183309342692965529850\n      );\n    \n      vk.IC[125] = encryptPairing.G1Point(\n        20329415554516877375217113870828644526746503543174947927856324253323347548006,\n        6449372889176304047154786871724291433870641783039538876936928626351282015218\n      );\n    \n      vk.IC[126] = encryptPairing.G1Point(\n        8703370927531146208105442970194299997309910427227005940989431524621541886301,\n        8481724521060081718547154630362864992339159690989979234424148015529107392488\n      );\n    \n      vk.IC[127] = encryptPairing.G1Point(\n        2444063919204377383395120723185081427943827868492127049128940541986852190222,\n        14128046871354720723874020003371592896633362026947614149140629591768067619770\n      );\n    \n      vk.IC[128] = encryptPairing.G1Point(\n        8415627394285483855270393575330671580483384768115516646376243496615517665285,\n        17644250029756010211665215078161309230078129129422746340462618360803298035600\n      );\n    \n      vk.IC[129] = encryptPairing.G1Point(\n        3420544616848538080940579776042340612990256087250742231081119638072428787117,\n        15124713204400782044487885678782213517451323200335820284578836659250889041892\n      );\n    \n      vk.IC[130] = encryptPairing.G1Point(\n        1564245801997425718382280489724836850822750300017393477443244818389780663290,\n        6120586977629499327202774577167097825581522585133459360495375352839903607783\n      );\n    \n      vk.IC[131] = encryptPairing.G1Point(\n        17519320847990329914497575615358210065555098199222222296918421182380766941772,\n        8328259405730347914371477093866729706175195925006858503722041189640571342595\n      );\n    \n      vk.IC[132] = encryptPairing.G1Point(\n        9710880389477840553981285873098159392153275967605466458685637424578131491646,\n        2230054815264577522743867991619715034814361480365371282957018775706781647816\n      );\n    \n      vk.IC[133] = encryptPairing.G1Point(\n        9482925022341053498277608830000986498334292434665425781410041121467500002837,\n        3800395987897034845032050473194666530533101792719476488145327140138397251846\n      );\n    \n      vk.IC[134] = encryptPairing.G1Point(\n        12507214322024030786577470202868531407233108157860452579063868060396902861570,\n        15820304496516292799914080383874882076864929634625874051166404986966832704665\n      );\n    \n      vk.IC[135] = encryptPairing.G1Point(\n        20763081988280083412769462956242780799179670317114865944659859005519456636676,\n        15691375105487753870608273069484019486572828314750781926152488377221798653035\n      );\n    \n      vk.IC[136] = encryptPairing.G1Point(\n        19214220891652655352367947936662890279525050992003302662813131246715340292214,\n        8273506224413326931382118460887469456861316079898107978940780286835666042566\n      );\n    \n      vk.IC[137] = encryptPairing.G1Point(\n        16250361512863769595445016252743329205704071149126001191390826108914219814108,\n        8019520753159772201972857326664781623639074605942469221086732660026352808370\n      );\n    \n      vk.IC[138] = encryptPairing.G1Point(\n        13142614938465375189297423121200020262080315005619266714070808906077519018391,\n        12766753482027313142000309387276376312049967353534764966326335896181372210468\n      );\n    \n      vk.IC[139] = encryptPairing.G1Point(\n        11165396909176963524756185443660089444666063011116415892360286686305516936712,\n        6448474579388660045651398791349495885431228346088260227092662612371516722683\n      );\n    \n      vk.IC[140] = encryptPairing.G1Point(\n        8004331101119352321105917835536091383244019353664408456901847281024468415761,\n        15928714708247704075117754281752307831966145592939095644722166259338263921402\n      );\n    \n      vk.IC[141] = encryptPairing.G1Point(\n        14633046731513846800157105757528455046351879444800905791824016223289541479387,\n        4052709342794477689976682518815260631741515038890413663553774696540272979697\n      );\n    \n      vk.IC[142] = encryptPairing.G1Point(\n        471534000739620818721070583904871392402221859064961313553516405751987681541,\n        7462162538905481599933975841507716253363517741825227348286674212380221922431\n      );\n    \n      vk.IC[143] = encryptPairing.G1Point(\n        19517077519713811100974676477419000426152107126131547585252423045748715490954,\n        16063722676969714572917706503446535930102124082067383549971364803573902488882\n      );\n    \n      vk.IC[144] = encryptPairing.G1Point(\n        16419563611779525677348755977707850698148350983888578599701286782310390565962,\n        7676917752061601119236277994108436379449681093759289717560034181428793225676\n      );\n    \n      vk.IC[145] = encryptPairing.G1Point(\n        17502424156508850673280085372582527771092623816579547692603884498914053942690,\n        18423457500046903195915923643475899077535790258332615337551773426030781924142\n      );\n    \n      vk.IC[146] = encryptPairing.G1Point(\n        19220228106183079778777410209769023183629038709280886176339115148328506277329,\n        4574298308341651074113391366204930341988816468233178025942726981109749720371\n      );\n    \n      vk.IC[147] = encryptPairing.G1Point(\n        21742977272516357250199281137117853063877507593824048567161250299117175800812,\n        18482212082094354206459407842061248009547184606101385582745606431164391617352\n      );\n    \n      vk.IC[148] = encryptPairing.G1Point(\n        16290556965944364442982273105004343271731313331573959068954388305485342335724,\n        15807273274067135680145240025807252954114599844494108869765971882330523266145\n      );\n    \n      vk.IC[149] = encryptPairing.G1Point(\n        10805657209575878945866474272499309737386574426903046910064316056174857422526,\n        6058328211874488315423481654895429210041524171067672128014494964700315589963\n      );\n    \n      vk.IC[150] = encryptPairing.G1Point(\n        9063414810167568151701542929850626647008947373911425483677001686604255890187,\n        16338796767808429355045569786644614555756848296223144582208445259715641226922\n      );\n    \n      vk.IC[151] = encryptPairing.G1Point(\n        13496925187633690674019437755832604662820805947256323161480077256715161319894,\n        20035215720820269483295550804856788956656545052276313719338715669330646147795\n      );\n    \n      vk.IC[152] = encryptPairing.G1Point(\n        18765966381262750278484753551777096045342623413180053451012811077175931561799,\n        11796266525650843616535605772197570632414959889519321131559917053251050460892\n      );\n    \n      vk.IC[153] = encryptPairing.G1Point(\n        17442877458278119104926012558382097236620236886870314485482616825907285024869,\n        11940605756826624838218304712496520992038981954475591837668546790429982265499\n      );\n    \n      vk.IC[154] = encryptPairing.G1Point(\n        11134871309381083816596724750211617452008881167217841358827456519462616268204,\n        14057457932644240612707744994223745949767688310133526083501335345076991976914\n      );\n    \n      vk.IC[155] = encryptPairing.G1Point(\n        4941348211937120433839766690409269776702249909217310196550086255032697563681,\n        5432582764187564298867775799410512330247279391180406107858752163480030295631\n      );\n    \n      vk.IC[156] = encryptPairing.G1Point(\n        21782525233881664739009709468194144874622293618252951763669244734739593735205,\n        21312136762871903232364300303547806266575721667135187728014057861204533080858\n      );\n    \n      vk.IC[157] = encryptPairing.G1Point(\n        17380149958687738505520548619665418539190296370998648966756702476762492982275,\n        20522149316755984264279027013039048394987054617834994407767815316367594470384\n      );\n    \n      vk.IC[158] = encryptPairing.G1Point(\n        2582218068341216336213497298044236157779910564694347890528355806565020810568,\n        17119519632377543486922998160754386915918297475956639389316301234138807353927\n      );\n    \n      vk.IC[159] = encryptPairing.G1Point(\n        13274115116838299054158922388420425008313236376713424589822192721350293218134,\n        9207618440296471432332155677680960207598201865140698773141886746960618528245\n      );\n    \n      vk.IC[160] = encryptPairing.G1Point(\n        20749414462129553176864664895313322584803170481450286528002182723334344549848,\n        18390118547490696549018775907585334192921262672644643958359267900029434132106\n      );\n    \n      vk.IC[161] = encryptPairing.G1Point(\n        19594727287236983928182875724292950896041140720338569347123192092400459795668,\n        1447089770585005670899930255249475548398824138156450274378044792072258045296\n      );\n    \n      vk.IC[162] = encryptPairing.G1Point(\n        14783430521342404579236610313946536304206668110142112114096818531141884325330,\n        20809814492866748878018344467013961882552579076797322264209800162322425757378\n      );\n    \n      vk.IC[163] = encryptPairing.G1Point(\n        12289900779305463023012085213976252312766565696149115580870272479769049120074,\n        6056585194303160688786687176847081370852126543130698431753701442086647031138\n      );\n    \n      vk.IC[164] = encryptPairing.G1Point(\n        6950499730711305377117434941889701884279626388402598243856216882963591313518,\n        19052280146997920569958923596769928092628900129958376457064641703697834711880\n      );\n    \n      vk.IC[165] = encryptPairing.G1Point(\n        15066117095365527540588576605266705006307924000518038923257277021551635281845,\n        16969928170546248252904591059982117643119971190833252948906469945625707690180\n      );\n    \n      vk.IC[166] = encryptPairing.G1Point(\n        21256575457741255522070731429214522144863710439972604086169883510586427819283,\n        11334987487528641100471547945902133506134944935423212951037781023427132737944\n      );\n    \n      vk.IC[167] = encryptPairing.G1Point(\n        6175276742736845490781433049451289219471942771816711833809108746848312120812,\n        16231369018441045162425068719653748720588382558717659735443052430382145991104\n      );\n    \n      vk.IC[168] = encryptPairing.G1Point(\n        12423284640810708714425995864819356819775325091959957280232485819022240658269,\n        12759929181739440354987332212004991972236026326998900088875335171811059533194\n      );\n    \n      vk.IC[169] = encryptPairing.G1Point(\n        9103932002748017153340735353939155270686357657906124262667421870786428491580,\n        19438862684548149751346552208528285443592200020729940710726767285449583470480\n      );\n    \n      vk.IC[170] = encryptPairing.G1Point(\n        6382027586862376306855308928329787784291281261288450623266799775262693688774,\n        17366139362667013512081327848683933829974924859271099078854376118995848577708\n      );\n    \n      vk.IC[171] = encryptPairing.G1Point(\n        9147431376956806103778529157659075421734217076246356863936167697146790416940,\n        21628315825739849457950092190205197276685177413377698509187151889941122594238\n      );\n    \n      vk.IC[172] = encryptPairing.G1Point(\n        758303348416511383395803334324848914017474163845119582192317881000006691320,\n        11350560771711338338713572553327837055354349380376356552730751040886900625679\n      );\n    \n      vk.IC[173] = encryptPairing.G1Point(\n        5309646695200013560310571549408285951873160802900077759703120556169051744086,\n        8347883785714374670787819638066831203156160861076048718433399875707768005125\n      );\n    \n      vk.IC[174] = encryptPairing.G1Point(\n        17674454940492559839735282084096117299451565174497635484593017432544329719057,\n        14133183194844463136475167639822626091693511305715024700926991353622243241121\n      );\n    \n      vk.IC[175] = encryptPairing.G1Point(\n        815180562706050532896921303617466322858383844326400937427021357334931469970,\n        3603345675314353737403469436406427706997978194268398562800618314628855617409\n      );\n    \n      vk.IC[176] = encryptPairing.G1Point(\n        3213325337336154546626494971576575791010853731489416888148124340874709125343,\n        7695264536083474038512759673495598044362614741237231880971462986152387111975\n      );\n    \n      vk.IC[177] = encryptPairing.G1Point(\n        12115023249888021438270504966833913761164274193400915684796241993578195206526,\n        11527208988816979929874778672079402829297155649170584564639302158758200011481\n      );\n    \n      vk.IC[178] = encryptPairing.G1Point(\n        3803306692538553179345317235873037999770920578701313888228405043823655835003,\n        11131226839114979436275380840139750835216115734782626510181135405095141877688\n      );\n    \n      vk.IC[179] = encryptPairing.G1Point(\n        10974316634300737151067032253479063898439671834369132649583908171740468895556,\n        6347817652291327629071711289159895029463719873645175996277811878215237492453\n      );\n    \n      vk.IC[180] = encryptPairing.G1Point(\n        9237886916455579684322539335972769740098370169774562268645496857848127426002,\n        2448917225022557983705369437697493453986309585998570543984953234410734301478\n      );\n    \n      vk.IC[181] = encryptPairing.G1Point(\n        2035450513051207153000660638346860773076862622882761254103070537213352756628,\n        18471912403571568484945329367609084826262950345950895821409094632318997526672\n      );\n    \n      vk.IC[182] = encryptPairing.G1Point(\n        18648445434368678816314988969889262590481108937132931876931504041755071632162,\n        14006384079198825473376100115117081406287245236646779681050915056227512843883\n      );\n    \n      vk.IC[183] = encryptPairing.G1Point(\n        19050173660058773952134982833156283534854983496915498874946401436275613967320,\n        7641231471867894592016369942064765602650277806793243774109236528925915794224\n      );\n    \n      vk.IC[184] = encryptPairing.G1Point(\n        7153761688521924775322507836306567166711669564523940842734855791353643048829,\n        13995802104266178711526070885875640765111235847382571060483964780033185406986\n      );\n    \n      vk.IC[185] = encryptPairing.G1Point(\n        17807743541243785483845692929364090891007718824039092754311548533697095181705,\n        12247491845696401979098323058465018486994049062537522066575462211455076395677\n      );\n    \n      vk.IC[186] = encryptPairing.G1Point(\n        9709899624799746124433657031322655993206186474905498096981946907459253112529,\n        16812692079254346882145344973048552530218143039043947823052397810738895992295\n      );\n    \n      vk.IC[187] = encryptPairing.G1Point(\n        7971673182969114449916575087673907972750587128810636232958293656027741313820,\n        6356638681566705155984797598695874002883229851425799430432845555566782269644\n      );\n    \n      vk.IC[188] = encryptPairing.G1Point(\n        2484387865555363668284602040467284126910436828644270703430972900669948840262,\n        6610652364042234297270557085690667771633801657030495701978085619650010224868\n      );\n    \n      vk.IC[189] = encryptPairing.G1Point(\n        13861755832886637946006548880453807404864149801408340163048426568736625186339,\n        2488244185072796578933233508222928031560347536497545773127275016330279015650\n      );\n    \n      vk.IC[190] = encryptPairing.G1Point(\n        8666725742553028838132589176577663876959852024010152822535871693260329145920,\n        5187911047401203406208661366134673805726101306916079710034017222873503113144\n      );\n    \n      vk.IC[191] = encryptPairing.G1Point(\n        9723992786834440260730805082746436125619614999894452411915070430914398081304,\n        1897148851701936029849940538793243572698595483589264183157033667463129997129\n      );\n    \n      vk.IC[192] = encryptPairing.G1Point(\n        16367647283358955453385734166925455364976916504840874457379047837610952566431,\n        961098168482770753315847839487414602349222232313989353383128687705372805306\n      );\n    \n      vk.IC[193] = encryptPairing.G1Point(\n        20581925539391657110761170510137227208618105349712652240011608678630237946389,\n        2600452436541804237790918337089820615575634767191787217235585978718016668416\n      );\n    \n      vk.IC[194] = encryptPairing.G1Point(\n        4214894207212119749871603838823307300603412521668557028989526286118705608792,\n        11453108674828775033289988529519661641600758060607479200468950960744829611864\n      );\n    \n      vk.IC[195] = encryptPairing.G1Point(\n        9377351413770291006347526992866802658576881023050033875967437744698883020053,\n        2555068492670184634387004747394880984449735651802536357626944026206198824340\n      );\n    \n      vk.IC[196] = encryptPairing.G1Point(\n        2770232625666425186950349789391413648724053036461582852389040430398731225972,\n        5891454879435550054773468925969580713590851634052194930240680813482274442148\n      );\n    \n      vk.IC[197] = encryptPairing.G1Point(\n        15158176006563958244783181153677977406320092148168262530302393453800976482458,\n        19209549539193590903618417924255924733809462953887611296488600436541785890658\n      );\n    \n      vk.IC[198] = encryptPairing.G1Point(\n        14412082379332044441775083831073073440808915359486805035951263062665589328725,\n        17600014154743899319640548135934150299253267839813540518261941688368655458581\n      );\n    \n      vk.IC[199] = encryptPairing.G1Point(\n        3042574576746369060440224614351421367702625821230761209039868787244933257229,\n        10699198662208357435767194474612657428623379293847595234033336579848925017386\n      );\n    \n      vk.IC[200] = encryptPairing.G1Point(\n        15486819044941297610026620108975688692062481051374981480977563128694785618429,\n        18256550769867198130662538651383817628842982629464463421577944744541912956681\n      );\n    \n      vk.IC[201] = encryptPairing.G1Point(\n        18290935890005924924490609178625119633592629854281176556312078898412857905236,\n        1756468293661298825540730783768689844381631764658681966238863989018919357692\n      );\n    \n      vk.IC[202] = encryptPairing.G1Point(\n        21885070803126830188659844722140141547866430817970793275673595415187473428886,\n        1864784967439042433878913751377832634646075619049743629751303109896218757777\n      );\n    \n      vk.IC[203] = encryptPairing.G1Point(\n        19888808124687106408406515667004918131268959442191778302423299253148904550786,\n        5078580933297778001401802334136607234253372793719076028865870429396280697451\n      );\n    \n      vk.IC[204] = encryptPairing.G1Point(\n        1546812530759592280872248769951684251561743460905832234277149578079105768983,\n        18949634306967764873478268296192866556859380581604002106903659528458223060364\n      );\n    \n      vk.IC[205] = encryptPairing.G1Point(\n        2355938056270955136987471745214380105513522881415560353772001559875544277569,\n        18228406330960076550938016904314803092748445565148127179380695631632135624120\n      );\n    \n      vk.IC[206] = encryptPairing.G1Point(\n        12317702608519302955265662793052063276685019275368871764423898207780621195038,\n        2689966208835539749200647566267678100614069228011512520577951516814108275282\n      );\n    \n      vk.IC[207] = encryptPairing.G1Point(\n        8482650065548896723881376444891325091580548078537065886249763244016389218054,\n        18802716648612834110499102905813730747803553597329049166976220139412811775703\n      );\n    \n      vk.IC[208] = encryptPairing.G1Point(\n        18683696331853725610490424639141191435719943009194781882850397063945982234449,\n        7104863278286764120902860784369172352315548922533193889495933944843289278774\n      );\n    \n      vk.IC[209] = encryptPairing.G1Point(\n        10968081318080001847237182282294616910372332691112259601317623961400947256933,\n        11158166639632076427842176993886477064494841886928929897176217416581100711727\n      );\n  }\n\n}\n\ncontract encryptVerifier {\n  using encryptPairing for *;\n\n  struct Proof {\n    encryptPairing.G1Point A;\n    encryptPairing.G2Point B;\n    encryptPairing.G1Point C;\n  }\n\n  function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n    VerifyingKey memory vk1 = encryptKeyFirstHalf.verifyingKey();\n    vk.alfa1 = vk1.alfa1;\n    vk.beta2 = vk1.beta2;\n    vk.gamma2 = vk1.gamma2;\n    vk.delta2 = vk1.delta2;\n    vk.IC = new encryptPairing.G1Point[](210);\n    for (uint i = 0; i < 104; i++) {\n      vk.IC[i] = vk1.IC[i];\n    }\n\n    VerifyingKey memory vk2 = encryptKeySecondHalf.verifyingKey();\n    for (uint i = 104; i < 210; i++) {\n      vk.IC[i] = vk2.IC[i];\n    }\n  }\n\n  /// @dev Verifies a Semaphore proof. Reverts with InvalidProof if the proof is invalid.\n  function verifyProof(\n    uint[2] memory a,\n    uint[2][2] memory b,\n    uint[2] memory c,\n    uint[209] memory input\n  ) public view {\n    // If the values are not in the correct range, the encryptPairing contract will revert.\n    Proof memory proof;\n    proof.A = encryptPairing.G1Point(a[0], a[1]);\n    proof.B = encryptPairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n    proof.C = encryptPairing.G1Point(c[0], c[1]);\n\n    VerifyingKey memory vk = verifyingKey();\n\n    // Compute the linear combination vk_x of inputs times IC\n    if (input.length + 1 != vk.IC.length) revert encryptPairing.InvalidProof();\n    encryptPairing.G1Point memory vk_x = vk.IC[0];\n    for (uint i = 0; i < input.length; i++) {\n      vk_x = encryptPairing.addition(vk_x, encryptPairing.scalar_mul(vk.IC[i+1], input[i]));\n    }\n\n    // Check pairing\n    encryptPairing.G1Point[] memory p1 = new encryptPairing.G1Point[](4);\n    encryptPairing.G2Point[] memory p2 = new encryptPairing.G2Point[](4);\n    p1[0] = encryptPairing.negate(proof.A);\n    p2[0] = proof.B;\n    p1[1] = vk.alfa1;\n    p2[1] = vk.beta2;\n    p1[2] = vk_x;\n    p2[2] = vk.gamma2;\n    p1[3] = proof.C;\n    p2[3] = vk.delta2;\n    encryptPairing.pairingCheck(p1, p2);\n  }\n}\n"
    },
    "contracts/v2/decrypt_verifier.sol": {
      "content": "//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// 2019 OKIMS\n//      ported to solidity 0.6\n//      fixed linter warnings\n//      added requiere error messages\n//\n// 2021 Remco Bloemen\n//       cleaned up code\n//       added InvalidProve() error\n//       always revert with InvalidProof() on invalid proof\n//       make decryptPairing strict\n//\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\nlibrary decryptPairing {\n  error InvalidProof();\n\n  // The prime q in the base field F_q for G1\n  uint256 constant BASE_MODULUS = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n  // The prime moludus of the scalar field of G1.\n  uint256 constant SCALAR_MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n  struct G1Point {\n    uint256 X;\n    uint256 Y;\n  }\n\n  // Encoding of field elements is: X[0] * z + X[1]\n  struct G2Point {\n    uint256[2] X;\n    uint256[2] Y;\n  }\n\n  /// @return the generator of G1\n  function P1() internal pure returns (G1Point memory) {\n    return G1Point(1, 2);\n  }\n\n  /// @return the generator of G2\n  function P2() internal pure returns (G2Point memory) {\n    return\n      G2Point(\n        [\n          11559732032986387107991004021392285783925812861821192530917403151452391805634,\n          10857046999023057135944570762232829481370756359578518086990519993285655852781\n        ],\n        [\n          4082367875863433681332203403145435568316851327593401208105741076214120093531,\n          8495653923123431417604973247489272438418190587263600148770280649306958101930\n        ]\n      );\n  }\n\n  /// @return r the negation of p, i.e. p.addition(p.negate()) should be zero.\n  function negate(G1Point memory p) internal pure returns (G1Point memory r) {\n    if (p.X == 0 && p.Y == 0) return G1Point(0, 0);\n    // Validate input or revert\n    if (p.X >= BASE_MODULUS || p.Y >= BASE_MODULUS) revert InvalidProof();\n    // We know p.Y > 0 and p.Y < BASE_MODULUS.\n    return G1Point(p.X, BASE_MODULUS - p.Y);\n  }\n\n  /// @return r the sum of two points of G1\n  function addition(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n    // By EIP-196 all input is validated to be less than the BASE_MODULUS and form points\n    // on the curve.\n    uint256[4] memory input;\n    input[0] = p1.X;\n    input[1] = p1.Y;\n    input[2] = p2.X;\n    input[3] = p2.Y;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n    }\n    if (!success) revert InvalidProof();\n  }\n\n  /// @return r the product of a point on G1 and a scalar, i.e.\n  /// p == p.scalar_mul(1) and p.addition(p) == p.scalar_mul(2) for all points p.\n  function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n    // By EIP-196 the values p.X and p.Y are verified to less than the BASE_MODULUS and\n    // form a valid point on the curve. But the scalar is not verified, so we do that explicitelly.\n    if (s >= SCALAR_MODULUS) revert InvalidProof();\n    uint256[3] memory input;\n    input[0] = p.X;\n    input[1] = p.Y;\n    input[2] = s;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n    }\n    if (!success) revert InvalidProof();\n  }\n\n  /// Asserts the pairing check\n  /// e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n  /// For example pairing([P1(), P1().negate()], [P2(), P2()]) should succeed\n  function pairingCheck(G1Point[] memory p1, G2Point[] memory p2) internal view {\n    // By EIP-197 all input is verified to be less than the BASE_MODULUS and form elements in their\n    // respective groups of the right order.\n    if (p1.length != p2.length) revert InvalidProof();\n    uint256 elements = p1.length;\n    uint256 inputSize = elements * 6;\n    uint256[] memory input = new uint256[](inputSize);\n    for (uint256 i = 0; i < elements; i++) {\n      input[i * 6 + 0] = p1[i].X;\n      input[i * 6 + 1] = p1[i].Y;\n      input[i * 6 + 2] = p2[i].X[0];\n      input[i * 6 + 3] = p2[i].X[1];\n      input[i * 6 + 4] = p2[i].Y[0];\n      input[i * 6 + 5] = p2[i].Y[1];\n    }\n    uint256[1] memory out;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n    }\n    if (!success || out[0] != 1) revert InvalidProof();\n  }\n}\n\ncontract decryptVerifier {\n  using decryptPairing for *;\n\n  struct VerifyingKey {\n    decryptPairing.G1Point alfa1;\n    decryptPairing.G2Point beta2;\n    decryptPairing.G2Point gamma2;\n    decryptPairing.G2Point delta2;\n    decryptPairing.G1Point[] IC;\n  }\n\n  struct Proof {\n    decryptPairing.G1Point A;\n    decryptPairing.G2Point B;\n    decryptPairing.G1Point C;\n  }\n\n  function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n    vk.alfa1 = decryptPairing.G1Point(\n      14378794661994809316668936077887579852844330409586136188493910229510707683568,\n      19007180918058273234125706522281291487787880146734549337345180962710738215208\n    );\n\n    vk.beta2 = decryptPairing.G2Point(\n      [5920706861016946300912146506670818945013737603659177373891149557636543490740, 12055325713222300848813253111985210672218263044214498326157766255150057128762],\n      [9700420230412290932994502491200547761155381189822684608735830492099336040170, 14277278647337675353039880797101698215986155900184787257566473040310971051502]\n    );\n\n    vk.gamma2 = decryptPairing.G2Point(\n      [11559732032986387107991004021392285783925812861821192530917403151452391805634, 10857046999023057135944570762232829481370756359578518086990519993285655852781],\n      [4082367875863433681332203403145435568316851327593401208105741076214120093531, 8495653923123431417604973247489272438418190587263600148770280649306958101930]\n    );\n\n    vk.delta2 = decryptPairing.G2Point(\n      [14775193340486106785412518097791831523220390171193689425927766312700613407698, 2639006974166104660735007617629115075610687006489787811483101253678053727965],\n      [7033699777372929539950951174758152219641620046403661899994547705056627996272, 12757135341281669891528138934607500598040384987778485246835950609094761223515]\n    );\n\n    vk.IC = new decryptPairing.G1Point[](5);\n\n    \n      vk.IC[0] = decryptPairing.G1Point(\n        9666425137086650662037336904385157031772055490977677744261137988127815787584,\n        5394407372917647524486917008691392485984315432533679388723049511191446329374\n      );\n    \n      vk.IC[1] = decryptPairing.G1Point(\n        1029880746318880647873272012935051622608590720430145823323385938643967970819,\n        10519815370211771276212315568191981797045710057898860151276042150960108246790\n      );\n    \n      vk.IC[2] = decryptPairing.G1Point(\n        18679496006835754091909636639352593958358012713658166038623643889897044251963,\n        4195574608657694158130023234645666213596440321409392981763827641454293624821\n      );\n    \n      vk.IC[3] = decryptPairing.G1Point(\n        21233915107006272243099839554591143807433705314036839416373945066186606306898,\n        16302219708944780223707653399805613424179877972668265811493690905270060414617\n      );\n    \n      vk.IC[4] = decryptPairing.G1Point(\n        90263583263356702511448915611918453627788815788836443948321726965197381648,\n        1295786833271608162503943377766741245832505007368535148970418800924473144110\n      );\n    \n  }\n\n  /// @dev Verifies a Semaphore proof. Reverts with InvalidProof if the proof is invalid.\n  function verifyProof(\n    uint[2] memory a,\n    uint[2][2] memory b,\n    uint[2] memory c,\n    uint[4] memory input\n  ) public view {\n    // If the values are not in the correct range, the decryptPairing contract will revert.\n    Proof memory proof;\n    proof.A = decryptPairing.G1Point(a[0], a[1]);\n    proof.B = decryptPairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n    proof.C = decryptPairing.G1Point(c[0], c[1]);\n\n    VerifyingKey memory vk = verifyingKey();\n\n    // Compute the linear combination vk_x of inputs times IC\n    if (input.length + 1 != vk.IC.length) revert decryptPairing.InvalidProof();\n    decryptPairing.G1Point memory vk_x = vk.IC[0];\n    for (uint i = 0; i < input.length; i++) {\n      vk_x = decryptPairing.addition(vk_x, decryptPairing.scalar_mul(vk.IC[i+1], input[i]));\n    }\n\n    // Check pairing\n    decryptPairing.G1Point[] memory p1 = new decryptPairing.G1Point[](4);\n    decryptPairing.G2Point[] memory p2 = new decryptPairing.G2Point[](4);\n    p1[0] = decryptPairing.negate(proof.A);\n    p2[0] = proof.B;\n    p1[1] = vk.alfa1;\n    p2[1] = vk.beta2;\n    p1[2] = vk_x;\n    p2[2] = vk.gamma2;\n    p1[3] = proof.C;\n    p2[3] = vk.delta2;\n    decryptPairing.pairingCheck(p1, p2);\n  }\n}\n"
    },
    "contracts/v2/IBoardManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BoardManagerStorage.sol\";\nimport \"./Verifier.sol\";\n\n\ninterface IBoardManager {\n    // ========================== Events ==========================\n    event BoardCreated(address indexed creator);\n    event BoardRefreshed(address indexed refresher);\n    event JoinedBoard(address indexed player);\n    event Checked(address indexed checker);\n    event Raised(address indexed raiser);\n    event Called(address indexed caller);\n    event Folded(address indexed folder);\n    event NextPlayer(uint256 indexed playerIndex);\n    event GameStageChanged(GameStage indexed stage);\n    event StackRequested(address indexed requester);\n\n    event DeckShuffled(address indexed player);\n    event RevealProofProvided(\n        address indexed sender,\n        uint256 indexed cardIndex);\n    event BatchRevealProofProvided(\n        address indexed sender,\n        uint256 indexed cardCount);\n\n    // ========================== Public ==========================\n    // create a board for a new game, reverts when\n    // - the current board is not ended yet\n    // - parameter checking fails\n    function createBoard(uint256 requiredPlayers, uint256 bigBlindSize) external;\n\n    // simply going to the next board, for dev purpose, anyone can call it\n    function refreshBoard() external;\n    \n    // player call this function to join the created board, reverts when\n    // - user has joined\n    // - board players reach the limit\n    function joinBoard() external returns (uint256 playerIndex);\n\n    // player call this function to check, reverts when\n    // - it's not the player's turn\n    // - player is not in the pot anymore\n    // - player can't check according to the game logic\n    // - game stage mismatch\n    function check() external;\n\n    // player call this function to raise, reverts when\n    // - it's not the player's turn\n    // - player is not in the pot anymore\n    // - player can't raise according to the game logic\n    // - game stage mismatch\n    function raise(uint256 amount) external;\n\n    // player call this function to call, reverts when\n    // - it's not the player's turn\n    // - player is not in the pot anymore\n    // - player can't call according to the game logic\n    // - game stage mismatch\n    function call(uint256 amount) external;\n\n    // player call this function to fold, reverts when\n    // - it's not the player's turn\n    // - player is not in the pot anymore\n    // - player can't fold according to the game logic\n    // - game stage mismatch\n    function fold() external;\n    \n\n    // everyone needs to shuffle the deck in order of joining, fails when\n    // - user who's not his turn calls this func\n    // - user shuffle twice\n    // - proof verification fails\n    function shuffleDeck(ShuffleProof calldata proof) external;\n\n    // everyone needs to provide the reveal proof to reveal a specific card of the deck, fails when\n    // - user who's not his turn calls this func\n    // - user provide for that card twice\n    // - proof verification fails\n    function provideRevealProof(RevealProof[] calldata proof) external;\n\n    // call this function the contract will calculate the hands of all players and save the winner\n    // also transfers all the bets on the table to the winner\n    function announceWinner() external returns (address winner, uint256 highestScore);\n\n    // dev purpose, request test stack for playing, will send 1000 stack to the called\n    function requestStack() external;\n\n    // ========================== View functions ==========================\n    function getShuffleProof() external view returns (ShuffleProof memory);\n    function getRevealProofs(uint256[] memory cardIndexes) external view returns (RevealProof[] memory);\n\n    function canCall(address player, uint256 amount) external view returns (bool);\n    function canRaise(address player, uint256 amount) external view returns (bool);  \n    function canCheck(address player) external view returns (bool);  \n    function canFold(address player) external view returns (bool);\n    \n    function amountToCall() external view returns (uint256);  \n    function smallBlindSize() external view returns (uint256);\n}\n"
    },
    "contracts/v2/BoardManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BoardManagerStorage.sol\";\nimport \"./IBoardManager.sol\";\nimport \"./Verifier.sol\";\nimport \"./GameUtils.sol\";\n\nenum BetType {\n    Call,\n    Fold,\n    Raise,\n    Check\n}\n\ncontract BoardManager is Ownable, IBoardManager, GameUtils {\n    // the current board data\n    // Solidity: it's have to be private to expose the dynamic members with a view function\n    Board board;\n\n    // mapping player address -> player index of joining\n    mapping(address => uint256) playerIndexesMap;\n\n    // mapping player address -> player in pot status\n    mapping(address => bool) playerInPotsMap;\n\n    bool public globalPaused;\n\n    address public verifier;\n\n    uint256 public immutable MIN_BIG_BLIND_SIZE = 10;\n    uint256 public immutable MIN_PLAYERS = 3;\n\n    // ========================= Modiftiers =============================\n    modifier onlyGameStages(GameStage stage) {\n        require(stage == board.stage, \"invalid game stage\");\n        _;\n    }\n\n    modifier checkExist() {\n        uint256 index = playerIndexesMap[msg.sender];\n        require(board.playerAddresses[index] == msg.sender, \"player not joined\");\n        _;\n    }\n\n    modifier checkTurn() {\n        require(\n            board.nextPlayerToPlay == playerIndexesMap[msg.sender],\n            \"not your turn\"\n        );\n        _;\n    }\n    \n    // ====================================================================\n    // ========================= Public functions =========================\n    // these public functions are intended to be interacted with end users\n    // ====================================================================\n    constructor(address verifier_) {\n        require(verifier_ != address(0), \"zero address verifier\");\n        verifier = verifier_;\n    }\n\n    // we can't export dynamic mappings, so it's a workaround\n    function getBoard() public view returns (Board memory) {\n        return board;\n    }\n\n    function createBoard(uint256 requiredPlayers, uint256 bigBlindSize)\n        external\n        override\n        onlyGameStages(GameStage.Uncreated)\n    {\n        require(\n            requiredPlayers >= MIN_PLAYERS &&\n                bigBlindSize >= MIN_BIG_BLIND_SIZE,\n            \"required players >= 3 && big blind size >= 10\"\n        );\n\n        // create board, stage is already created\n        refreshBoard();\n        board.requiredPlayers = requiredPlayers;\n        board.bigBlindSize = bigBlindSize;\n        emit BoardCreated(msg.sender);\n    }\n\n    function refreshBoard() public override {\n        _clearMappings();\n        uint256[] memory cards = createInitialCards();\n        board.stage = GameStage.GatheringPlayers;\n        board.playerAddresses = new address[](0);\n        board.playerHands = new uint256[][](0);\n        board.playerBets = new uint256[](0);\n        board.playerStacks = new uint256[](0);\n        board.playerInPots = new bool[](0);\n        board.communityCards = new uint256[](0);\n        board.deck = cards;\n        board.winner = address(0);\n        board.potSize = 0;\n\n        // we don't set dealer index and next player index till we done player gathering\n\n        emit BoardRefreshed(msg.sender);\n    }\n\n    function joinBoard()\n        external\n        override\n        onlyGameStages(GameStage.GatheringPlayers)\n        returns (uint256)\n    {\n        require(!playerInPotsMap[msg.sender], \"already joined\");\n\n        uint256[] memory initialHand = new uint256[](0);\n        board.playerAddresses.push(msg.sender);\n        board.playerHands.push(initialHand);\n        board.playerBets.push(0);\n        // get 1000 stack initially\n        board.playerStacks.push(1000);\n        board.playersDoneForCurrentStage.push(true);\n        board.playerInPots.push(true);\n\n         // set flag\n        playerInPotsMap[msg.sender] = true;\n        playerIndexesMap[msg.sender] = board.playerAddresses.length - 1;\n\n        // when enough players are there, let's go\n        if (board.playerAddresses.length == board.requiredPlayers) {\n            board.stage = GameStage.Shuffle;\n            // dealer index is always the last joined player\n            board.dealerIndex = board.playerAddresses.length - 1;\n            // next player to play is 1 ahead of dealer index, which is 0\n            board.nextPlayerToPlay = 0;\n            // set big blind bet size and small blind bet size\n            board.playerBets[0] = board.bigBlindSize;\n            board.playerStacks[0] -= board.bigBlindSize;\n            board.playerBets[1] = board.bigBlindSize / 2;\n            board.playerStacks[1] -= board.bigBlindSize / 2;\n        }\n\n        emit JoinedBoard(msg.sender);\n\n        // return the index\n        return board.playerAddresses.length - 1;\n    }\n\n    function check() external override {\n        _performBet(BetType.Check);\n    }\n\n    function call(uint256 amount) external override {\n        _performBetWithAmount(BetType.Call, amount);\n    }\n\n    function raise(uint256 amount) external override {\n        _performBetWithAmount(BetType.Raise, amount);\n    }\n\n    function fold() external override {\n        _performBet(BetType.Fold);\n    }\n\n    function shuffleDeck(ShuffleProof calldata proof)\n        external\n        override\n        // onlyGameStages(GameStage.Shuffle)\n        // checkTurn\n        // checkExist\n    {\n        require(verifier != address(0), \"empty verifier\");\n        require(\n            Verifier(verifier).verifyShuffleAndSave(proof),\n            \"verification failed\"\n        );\n\n        emit DeckShuffled(msg.sender);\n        // _moveToTheNext();\n    }\n\n    function provideRevealProof(RevealProof[] calldata proofs)\n        external\n        override\n        // checkExist\n        // checkTurn\n    {\n        // needs provide proofs in preflop and flop round\n        // require(isRevealRound(), \"cannot reveal proof\");\n        require(proofs.length > 0, \"empty proofs\");\n\n        uint256 cardStartIndex;\n        if (board.stage == GameStage.PreFlop) {\n            cardStartIndex = 0;\n        } else if (board.stage == GameStage.Flop) {\n            cardStartIndex = 6;\n        } else if (board.stage == GameStage.Turn) {\n            cardStartIndex = 9;\n        } else if (board.stage == GameStage.River) {\n            cardStartIndex = 10;\n        }\n        \n        for (uint256 i = 0; i < proofs.length; ++i) {\n            _provideRevealProof(\n                cardStartIndex + i,\n                proofs[i]);\n        }\n        emit BatchRevealProofProvided(msg.sender, proofs.length);\n\n        if (playerInPotsMap[msg.sender]) {  // already fold, do nothing except reveal\n            _moveToTheNext();\n        }\n    }\n\n    // extremely simplfied version of competing\n    function announceWinner()\n        external\n        override\n        onlyGameStages(GameStage.PostRound)\n        returns (address winner, uint256 highestScore)\n    {\n        for (uint256 i = 0; i < board.playerAddresses.length; ++i) {\n            uint256 score = 0;\n            uint256[] storage cards = board.playerHands[i];\n            for (uint256 j = 0; j < cards.length; ++j) {\n                score += cards[j];\n            }\n            if (highestScore < score) {\n                highestScore = score;\n                winner = board.playerAddresses[i];\n            }\n        }\n        // save winner\n        board.winner = winner;\n    }\n\n    function requestStack() external override checkExist {\n        uint256 playerIndex = playerIndexesMap[msg.sender];\n        board.playerStacks[playerIndex] += 1000;\n        emit StackRequested(msg.sender);\n    }\n\n    // ====================================================================\n    // ========================== View functions ==========================\n    // ====================================================================\n    function getShuffleProof()\n        public\n        view\n        override\n        returns (ShuffleProof memory)\n    {\n        return Verifier(verifier).getShuffleProof();\n    }\n\n    function getRevealProofs(uint256[] memory cardIndexes)\n        public\n        view\n        override\n        returns (RevealProof[] memory proofs)\n    {\n        require(cardIndexes.length > 0, \"\");\n        proofs = new RevealProof[](cardIndexes.length);\n        for (uint256 i = 0; i < cardIndexes.length; ++i) {\n            RevealProof memory proof = Verifier(verifier).getRevealProof(cardIndexes[i]);\n            proofs[i] = proof;\n        }\n    }\n\n    function isBetRound() public view returns (bool) {\n        return board.stage == GameStage.PreFlopBet\n            || board.stage == GameStage.FlopBet\n            || board.stage == GameStage.TurnBet\n            || board.stage == GameStage.RiverBet;\n    }\n\n    function isRevealRound() public view returns (bool) {\n        return board.stage == GameStage.PreFlop \n            || board.stage == GameStage.Flop \n            || board.stage == GameStage.Turn \n            || board.stage == GameStage.River\n            // in the post round, everyone needs to provide proof to open the card\n            || board.stage == GameStage.PostRound;\n    }\n\n    function canCall(address player, uint256 amount)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return isBetRound() &&\n            board.nextPlayerToPlay == playerIndexesMap[player] &&\n            playerInPotsMap[player];\n        // todo: && betAmount > lastBetAmount\n    }\n\n    function canCheck(address player) public view override returns (bool) {\n        return isBetRound() &&\n            board.nextPlayerToPlay == playerIndexesMap[player] &&\n            playerInPotsMap[player];\n        // && nobodyBet()\n    }\n\n    function canRaise(address player, uint256 amount)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return isBetRound() &&\n            board.nextPlayerToPlay == playerIndexesMap[player] &&\n            playerInPotsMap[player];\n        // todo: && betAmount > lastBetAmount\n    }\n\n    function canFold(address player) public view override returns (bool) {\n        return isBetRound() &&\n            board.nextPlayerToPlay == playerIndexesMap[player] &&\n            playerInPotsMap[player];\n    }\n\n    // todo\n    function amountToCall() public view override returns (uint256) {}\n\n    function smallBlindSize() public view override returns (uint256) {\n        return board.bigBlindSize / 2;\n    }\n\n\n    // ====================================================================\n    // ========================= Internals functions ======================\n    // ====================================================================\n\n    function _moveToTheNext() internal returns (bool gameStageChanged) {\n        // if there is no players joined, like while creating board, we move to the next round\n        if (\n            board.playerAddresses.length > 0 &&\n            board.nextPlayerToPlay != board.dealerIndex\n        ) {\n            board.nextPlayerToPlay++;\n            // skip the users have fold\n            address nextPlayer = board.playerAddresses[board.nextPlayerToPlay];\n            // we can skip reveal round, otherwise we can't get complete reveal proof\n            if (!playerInPotsMap[nextPlayer] && !isRevealRound()) {\n                return _moveToTheNext();\n            }\n            emit NextPlayer(board.nextPlayerToPlay);\n            return false;\n        }\n        uint256 nextStatus = uint256(board.stage) + 1;\n        // when the status reach the end, there is no way for this game to be replayed\n        require(\n            nextStatus <= uint256(GameStage.PostRound),\n            \"game already ended\"\n        );\n\n        // now it's another round\n        board.stage = GameStage(nextStatus);\n        board.nextPlayerToPlay = 0; // (board.dealerIndex + 1) % playerCount\n        emit GameStageChanged(GameStage(nextStatus));\n\n        // post round\n        _postRound();\n\n        return true;\n    }\n\n    // Do something right after the game stage updated\n    function _postRound() internal {\n        uint256 len = board.playerAddresses.length;\n        if (board.stage == GameStage.PreFlop) {\n            // now it's preflop, assign 2 cards to each players\n            for (uint256 i = 0; i < len; ++i) {\n                board.playerHands[i] = new uint256[](2);\n                board.playerHands[i][0] = i * 2;\n                board.playerHands[i][1] = i * 2 + 1;\n            }\n        } else if (board.stage == GameStage.Flop) {\n            // now it's flop, assign 3 cards to community deck\n            board.communityCards = new uint256[](3);\n            board.communityCards[0] = len * 2;\n            board.communityCards[1] = len * 2 + 1;\n            board.communityCards[2] = len * 2 + 2;\n        }\n        else if (board.stage == GameStage.Turn) {\n            // now it's turn, assign 1 card to community deck\n            board.communityCards.push(len * 2 + 3);\n        }\n        else if (board.stage == GameStage.River) {\n            // now it's river, assign 1 card to community deck\n            board.communityCards.push(len * 2 + 4);\n        }\n        else if (board.stage == GameStage.Ended) {\n            _saveWinner();\n        }\n    }\n\n    function _performBetWithAmount(BetType betType, uint256 amount)\n        internal\n        checkExist\n        checkTurn\n    {\n        require(isBetRound(), \"can't bet now\");\n        uint256 playerIndex = playerIndexesMap[msg.sender];\n\n        if (betType == BetType.Call) {\n            require(canCall(msg.sender, amount), \"cannot call\");\n            require(\n                board.playerStacks[playerIndex] >= amount,\n                \"insufficient amount\"\n            );\n            board.playerStacks[playerIndex] -= amount;\n            board.playerBets[playerIndex] += amount;\n            board.potSize += amount;\n        } else if (betType == BetType.Raise) {\n            require(canRaise(msg.sender, amount), \"cannot raise\");\n            board.playerStacks[playerIndex] -= amount;\n            board.playerBets[playerIndex] += amount;\n            board.potSize += amount;\n        } else if (betType == BetType.Check) {\n            require(canCheck(msg.sender), \"cannot raise\");\n            // nothing happens when check\n        } else if (betType == BetType.Fold) {\n            require(canFold(msg.sender), \"cannot fold\");\n            playerInPotsMap[msg.sender] = false;\n            board.playerInPots[playerIndex] = false;\n            if(_tryAnnounceWinnerDirectly()) {\n                return;\n            }\n        }\n        // play is done for this round\n        board.playersDoneForCurrentStage[playerIndex] = true;\n        _moveToTheNext();\n    }\n\n    function _performBet(BetType betType) internal {\n        _performBetWithAmount(betType, 0);\n    }\n\n    function _provideRevealProof(\n        uint256 cardStartIndex,\n        RevealProof calldata proof) internal {\n        require(verifier != address(0), \"empty verifier\");\n        require(\n            Verifier(verifier).verifyRevealAndSave(cardStartIndex, proof),\n            \"verification failed\"\n        );\n    }\n\n    function _clearMappings() internal {\n        address[] storage addrs = board.playerAddresses;\n        for (uint256 i = 0; i < addrs.length; ++i) {\n            delete playerInPotsMap[addrs[i]];\n            delete playerIndexesMap[addrs[i]];\n        }\n    }\n\n    // if there is only one player left, announce winner directly\n    function _tryAnnounceWinnerDirectly() internal returns (bool hasWinner) {\n        uint256 stillInPot;\n        uint256 winnerIndex;\n        for (uint256 i = 0; i < board.playerInPots.length; ++i) {\n            if(board.playerInPots[i]) {\n                stillInPot++;\n                winnerIndex = i;\n            }\n        }\n        if (stillInPot == 1) {\n            board.winner = board.playerAddresses[winnerIndex];\n            board.stage = GameStage.Ended;\n            board.playerStacks[winnerIndex] += board.potSize; \n            board.potSize = 0;\n            hasWinner = true;\n        }\n    }\n\n    function _saveWinner() internal {\n        uint highestScore;\n        for (uint256 i = 0; i < board.playerAddresses.length; ++i) {\n            if (!board.playerInPots[i]) {\n                continue;\n            }\n            uint256 score = 0;\n            uint256[] storage cards = board.playerHands[i];\n            for (uint256 j = 0; j < cards.length; ++j) {\n                score += cards[j];\n            }\n            if (highestScore < score) {\n                highestScore = score;\n                board.winner = board.playerAddresses[i];\n            }\n        }\n    }\n\n}\n\n"
    },
    "contracts/v2/GameUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BoardManagerStorage.sol\";\n\ncontract GameUtils {\n    uint256 public immutable CARD_NUM = 52;\n\n    function createInitialCards()\n        internal\n        pure\n        returns (uint256[] memory cards)\n    {\n        cards = new uint256[](CARD_NUM);\n        for (uint256 i = 0; i < CARD_NUM; ++i) {\n            cards[i] = i + 1;\n        }\n        return cards;\n    }\n\n    function getCardInfo(uint256 val) public pure returns (CardInfo memory) {\n        return CardInfo({rank: Rank(val / 13), value: val % 13});\n    }\n}\n"
    },
    "contracts/v2/ZKVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * This contract contain all the cryptographic logic\n */\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// todo: change to the actual ZKP verifier\ncontract ZKVerifier {\n    // ========================== data fields ==========================\n\n    // ========================== Events ==========================\n\n    // ========================== public functions ==========================\n    constructor() {}\n\n    // ========================== internals ==========================\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}
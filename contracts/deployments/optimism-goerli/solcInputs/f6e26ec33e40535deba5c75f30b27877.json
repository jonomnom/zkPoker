{
  "language": "Solidity",
  "sources": {
    "contracts/v2/Verifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * This contract contain all the cryptographic logic\n */\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BoardManagerStorage.sol\";\n\nstruct ShuffleProof {\n    uint256[2] proof;\n    uint256[] deck;\n}\n\nstruct RevealProof {\n    uint256[2] proof;\n    uint256 card;\n}\n\ncontract Verifier is Ownable {\n    // ========================== data fields ==========================\n    ShuffleProof private shuffleProof;\n\n    // key: cardIndex\n    mapping(uint256 => RevealProof) public revealProofs;\n\n    address public game;\n\n    // ========================== Events ==========================\n\n    event Setup();\n\n    function getShuffleProof() public view returns (ShuffleProof memory) {\n        return shuffleProof;\n    }\n\n    function getRevealProof(uint256 cardIndex)\n        public\n        view\n        returns (RevealProof memory)\n    {\n        return revealProofs[cardIndex];\n    }\n\n    function setup(uint256[] calldata startingDeck) external returns (bool) {\n        // set the initial proof and deck for this round\n        uint256[2] memory proof = [uint256(0), uint256(0)];\n        shuffleProof = ShuffleProof({proof: proof, deck: startingDeck});\n\n        revealProofs[0] = RevealProof({proof: proof, card: 0});\n\n        return true;\n    }\n\n    // verify shuffle proof with the last saved deck, and going on\n    function verifyShuffleAndSave(ShuffleProof calldata proof)\n        external\n        returns (bool)\n    {\n        // verifyShuffleByCircomGeneratedFunction(proof, last);\n\n        // save\n        shuffleProof = proof;\n        return true;\n    }\n\n    //\n    function verifyRevealAndSave(RevealProof calldata proof)\n        external\n        returns (bool)\n    {\n        // verifyDrawnByCircomGeneratedFunction(proof, last);\n\n        // save\n        revealProofs[proof.card] = proof;\n        return true;\n    }\n\n    // ========================== internals ==========================\n}\n"
    },
    "contracts/v2/BoardManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nenum GameStage {\n    Uncreated,\n    GatheringPlayers,\n    Shuffle,\n    PreFlop, // in pre-flop, every gets 2 cards, and everyone must provide proofs \n    PreFlopBet,\n    Flop, // in flop, everyone must provide proofs for community cards\n    // Turn,\n    // River,\n    PostRound,\n    Ended\n}\n\nenum Rank {\n    Spades, \n    Hearts,\n    Diamonds,\n    Clubs\n}\n\n// example: \n// card value: 50\n// card info: rank: 50 / 13 = 3 (Clubs), value: 50 % 13 = 11 (2,3,4,5,6,7,8,9,j,>>Q<<,k,a)\nstruct CardInfo {\n    Rank rank;\n    uint256 value;\n}\n\n// the board state\nstruct Board {\n    // the current game status\n    GameStage stage;\n\n    // player infos\n    address[] playerAddresses;\n    uint256[][] playerHands;\n    uint256[] playerBets;\n    uint256[] playerStacks;\n    bool[] playersDoneForCurrentStage;\n    bool[] playerInPots;\n\n    uint256[] communityCards;\n\n    // next player index to player\n    uint256 nextPlayerToPlay;\n\n    uint256 dealerIndex;\n\n    uint256 bigBlindSize;\n\n    // the cards on the deck, from index 0 to len - 1 represent from bottom to the top\n    // so we can perform pop card easily \n    uint256[] deck;\n\n    // zero address before game ends\n    address winner;\n\n    // the required amount of players for this board\n    uint256 requiredPlayers;\n\n    // total stack in the pot\n    uint256 potSize;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/v2/IBoardManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BoardManagerStorage.sol\";\nimport \"./Verifier.sol\";\n\n\ninterface IBoardManager {\n    // ========================== Events ==========================\n    event BoardCreated(address indexed creator);\n    event BoardRefreshed(address indexed refresher);\n    event JoinedBoard(address indexed player);\n    event Checked(address indexed checker);\n    event Raised(address indexed raiser);\n    event Called(address indexed caller);\n    event Folded(address indexed folder);\n    event NextPlayer(uint256 indexed playerIndex);\n    event GameStageChanged(GameStage indexed stage);\n    event StackRequested(address indexed requester);\n\n    event DeckShuffled(address indexed player);\n    event RevealProofProvided(\n        address indexed sender,\n        uint256 indexed cardIndex);\n    event BatchRevealProofProvided(\n        address indexed sender,\n        uint256 indexed cardCount);\n\n    // ========================== Public ==========================\n    // create a board for a new game, reverts when\n    // - the current board is not ended yet\n    // - parameter checking fails\n    function createBoard(uint256 requiredPlayers, uint256 bigBlindSize) external;\n\n    // simply going to the next board, for dev purpose, anyone can call it\n    function refreshBoard() external;\n    \n    // player call this function to join the created board, reverts when\n    // - user has joined\n    // - board players reach the limit\n    function joinBoard() external returns (uint256 playerIndex);\n\n    // player call this function to check, reverts when\n    // - it's not the player's turn\n    // - player is not in the pot anymore\n    // - player can't check according to the game logic\n    // - game stage mismatch\n    function check() external;\n\n    // player call this function to raise, reverts when\n    // - it's not the player's turn\n    // - player is not in the pot anymore\n    // - player can't raise according to the game logic\n    // - game stage mismatch\n    function raise(uint256 amount) external;\n\n    // player call this function to call, reverts when\n    // - it's not the player's turn\n    // - player is not in the pot anymore\n    // - player can't call according to the game logic\n    // - game stage mismatch\n    function call(uint256 amount) external;\n\n    // player call this function to fold, reverts when\n    // - it's not the player's turn\n    // - player is not in the pot anymore\n    // - player can't fold according to the game logic\n    // - game stage mismatch\n    function fold() external;\n    \n\n    // everyone needs to shuffle the deck in order of joining, fails when\n    // - user who's not his turn calls this func\n    // - user shuffle twice\n    // - proof verification fails\n    function shuffleDeck(ShuffleProof calldata proof) external;\n\n    // everyone needs to provide the reveal proof to reveal a specific card of the deck, fails when\n    // - user who's not his turn calls this func\n    // - user provide for that card twice\n    // - proof verification fails\n    function provideRevealProof(RevealProof[] calldata proof) external;\n\n    // open the cards in the caller's hand to the public, there are two cards so the proofs, fails when\n    // - user who's not his turn calls this func\n    // - user open for their cards twice\n    // - proof verification fails\n    function openCards(RevealProof[] calldata proofs) external returns (uint256[] memory);\n\n    // call this function the contract will calculate the hands of all players and save the winner\n    // also transfers all the bets on the table to the winner\n    function announceWinner() external returns (address winner, uint256 highestScore);\n\n    // dev purpose, request test stack for playing, will send 1000 stack to the called\n    function requestStack() external;\n\n    // ========================== View functions ==========================\n    function getShuffleProof() external view returns (ShuffleProof memory);\n    function getRevealProof(uint256 cardIndex) external view returns (RevealProof memory);\n\n    function canCall(address player, uint256 amount) external view returns (bool);\n    function canRaise(address player, uint256 amount) external view returns (bool);  \n    function canCheck(address player) external view returns (bool);  \n    function canFold(address player) external view returns (bool);\n    \n    function amountToCall() external view returns (uint256);  \n    function smallBlindSize() external view returns (uint256);\n}\n"
    },
    "contracts/v2/BoardManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BoardManagerStorage.sol\";\nimport \"./IBoardManager.sol\";\nimport \"./Verifier.sol\";\nimport \"./GameUtils.sol\";\n\nenum BetType {\n    Call,\n    Fold,\n    Raise,\n    Check\n}\n\ncontract BoardManager is Ownable, IBoardManager, GameUtils {\n    // the current board data\n    // Solidity: it's have to be private to expose the dynamic members with a view function\n    Board board;\n\n    // mapping player address -> player index of joining\n    mapping(address => uint256) playerIndexesMap;\n\n    // mapping player address -> player in pot status\n    mapping(address => bool) playerInPotsMap;\n\n    bool public globalPaused;\n\n    address public verifier;\n\n    uint256 public immutable MIN_BIG_BLIND_SIZE = 10;\n    uint256 public immutable MIN_PLAYERS = 3;\n\n    // ========================= Modiftiers =============================\n    modifier onlyGameStages(GameStage stage) {\n        require(stage == board.stage, \"invalid game stage\");\n        _;\n    }\n\n    modifier checkExist() {\n        require(playerInPotsMap[msg.sender], \"player not joined\");\n        _;\n    }\n\n    modifier checkTurn() {\n        require(\n            board.nextPlayerToPlay == playerIndexesMap[msg.sender],\n            \"not your turn\"\n        );\n        _;\n    }\n\n    // ========================= Public functions =============================\n    constructor(address verifier_) {\n        require(verifier_ != address(0), \"zero address verifier\");\n        verifier = verifier_;\n    }\n\n    // we can't export dynamic mappings, so it's a workaround\n    function getBoard() public view returns (Board memory) {\n        return board;\n    }\n\n    function createBoard(uint256 requiredPlayers, uint256 bigBlindSize)\n        external\n        override\n        onlyGameStages(GameStage.Uncreated)\n    {\n        require(\n            requiredPlayers >= MIN_PLAYERS &&\n                bigBlindSize >= MIN_BIG_BLIND_SIZE,\n            \"required players >= 3 && big blind size >= 10\"\n        );\n\n        // create board, stage is already created\n        refreshBoard();\n        board.requiredPlayers = requiredPlayers;\n        board.bigBlindSize = bigBlindSize;\n        emit BoardCreated(msg.sender);\n    }\n\n    function refreshBoard() public override {\n        _clearMappings();\n        uint256[] memory cards = createInitialCards();\n        board.stage = GameStage.GatheringPlayers;\n        board.playerAddresses = new address[](0);\n        board.playerHands = new uint256[][](0);\n        board.playerBets = new uint256[](0);\n        board.playerStacks = new uint256[](0);\n        board.playerInPots = new bool[](0);\n        board.communityCards = new uint256[](0);\n        board.deck = cards;\n        board.winner = address(0);\n        board.potSize = 0;\n\n        // we don't set dealer index and next player index till we done player gathering\n\n        emit BoardRefreshed(msg.sender);\n    }\n\n    function joinBoard()\n        external\n        override\n        onlyGameStages(GameStage.GatheringPlayers)\n        returns (uint256)\n    {\n        require(!playerInPotsMap[msg.sender], \"already joined\");\n\n        uint256[] memory initialHand = new uint256[](0);\n        board.playerAddresses.push(msg.sender);\n        board.playerHands.push(initialHand);\n        board.playerBets.push(0);\n        board.playerStacks.push(0);\n        board.playersDoneForCurrentStage.push(true);\n        board.playerInPots.push(true);\n\n         // set flag\n        playerInPotsMap[msg.sender] = true;\n        playerIndexesMap[msg.sender] = board.playerAddresses.length - 1;\n\n        // when enough players are there, let's go\n        if (board.playerAddresses.length == board.requiredPlayers) {\n            board.stage = GameStage.Shuffle;\n            // dealer index is always the last joined player\n            board.dealerIndex = board.playerAddresses.length - 1;\n            // next player to play is 1 ahead of dealer index, which is 0\n            board.nextPlayerToPlay = 0;\n        }\n\n        // return the index\n        return board.playerAddresses.length - 1;\n    }\n\n    function check() external override {\n        _performBet(BetType.Check);\n    }\n\n    function call(uint256 amount) external override {\n        _performBetWithAmount(BetType.Call, amount);\n    }\n\n    function raise(uint256 amount) external override {\n        _performBetWithAmount(BetType.Raise, amount);\n    }\n\n    function fold() external override {\n        _performBet(BetType.Fold);\n    }\n\n    function shuffleDeck(ShuffleProof calldata proof)\n        external\n        override\n        onlyGameStages(GameStage.Shuffle)\n        checkTurn\n        checkExist\n    {\n        require(verifier != address(0), \"empty verifier\");\n        require(\n            Verifier(verifier).verifyShuffleAndSave(proof),\n            \"verification failed\"\n        );\n\n        emit DeckShuffled(msg.sender);\n        _moveToTheNext();\n    }\n\n    function provideRevealProof(RevealProof[] calldata proofs)\n        external\n        override\n        checkExist\n        checkTurn\n    {\n        // needs provide proofs in preflop and flop round\n        require(\n            board.stage == GameStage.PreFlop || board.stage == GameStage.Flop,\n            \"cannot reveal proof\"\n        );\n        require(proofs.length > 0, \"empty proofs\");\n        for (uint256 i = 0; i < proofs.length; ++i) {\n            _provideRevealProof(proofs[i]);\n        }\n        emit BatchRevealProofProvided(msg.sender, proofs.length);\n        _moveToTheNext();\n    }\n\n    // todo\n    function openCards(RevealProof[] calldata proofs)\n        external\n        override\n        returns (uint256[] memory)\n    {}\n\n    // extremely simplfied version of competing\n    function announceWinner()\n        external\n        override\n        onlyGameStages(GameStage.PostRound)\n        returns (address winner, uint256 highestScore)\n    {\n        for (uint256 i = 0; i < board.playerAddresses.length; ++i) {\n            uint256 score = 0;\n            uint256[] storage cards = board.playerHands[i];\n            for (uint256 j = 0; j < cards.length; ++j) {\n                score += cards[j];\n            }\n            if (highestScore < score) {\n                highestScore = score;\n                winner = board.playerAddresses[i];\n            }\n        }\n        // save winner\n        board.winner = winner;\n    }\n\n    function requestStack() external override checkExist {\n        uint256 playerIndex = playerIndexesMap[msg.sender];\n        board.playerStacks[playerIndex] += 1000;\n        emit StackRequested(msg.sender);\n    }\n\n    // ========================== View functions ==========================\n    function getShuffleProof()\n        public\n        view\n        override\n        returns (ShuffleProof memory)\n    {\n        return Verifier(verifier).getShuffleProof();\n    }\n\n    function getRevealProof(uint256 cardIndex)\n        public\n        view\n        override\n        returns (RevealProof memory)\n    {\n        return Verifier(verifier).getRevealProof(cardIndex);\n    }\n\n    function canCall(address player, uint256 amount)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            board.nextPlayerToPlay == playerIndexesMap[player] &&\n            playerInPotsMap[player];\n        // todo: && betAmount > lastBetAmount\n    }\n\n    function canCheck(address player) public view override returns (bool) {\n        return\n            board.nextPlayerToPlay == playerIndexesMap[player] &&\n            playerInPotsMap[player];\n        // && nobodyBet()\n    }\n\n    function canRaise(address player, uint256 amount)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            board.nextPlayerToPlay == playerIndexesMap[player] &&\n            playerInPotsMap[player];\n        // todo: && betAmount > lastBetAmount\n    }\n\n    function canFold(address player) public view override returns (bool) {\n        return\n            board.nextPlayerToPlay == playerIndexesMap[player] &&\n            playerInPotsMap[player];\n    }\n\n    // todo\n    function amountToCall() public view override returns (uint256) {}\n\n    function smallBlindSize() public view override returns (uint256) {\n        return board.bigBlindSize / 2;\n    }\n\n    // ========================== Internals ==========================\n    function _moveToTheNext() internal returns (bool gameStageChanged) {\n        // if there is no players joined, like while creating board, we move to the next round\n        if (\n            board.playerAddresses.length > 0 &&\n            board.nextPlayerToPlay != board.dealerIndex\n        ) {\n            board.nextPlayerToPlay++;\n            // skip the users have fold\n            address nextPlayer = board.playerAddresses[board.nextPlayerToPlay];\n            if (!playerInPotsMap[nextPlayer]) {\n                return _moveToTheNext();\n            }\n            emit NextPlayer(board.nextPlayerToPlay);\n            return false;\n        }\n        uint256 nextStatus = uint256(board.stage) + 1;\n        // when the status reach the end, there is no way for this game to be replayed\n        require(\n            nextStatus <= uint256(GameStage.PostRound),\n            \"game already ended\"\n        );\n\n\n        // now it's another round\n        board.stage = GameStage(nextStatus);\n        board.nextPlayerToPlay = 0; // (board.dealerIndex + 1) % playerCount\n        emit GameStageChanged(GameStage(nextStatus));\n\n        // post round\n        _postRound();\n\n        return true;\n    }\n\n    function _postRound() internal {\n        uint256 len = board.playerAddresses.length;\n        if (board.stage == GameStage.PreFlop) {\n            // now it's preflop, assign 2 cards to each players\n            for (uint256 i = 0; i < len; ++i) {\n                board.playerHands[i] = new uint256[](2);\n                board.playerHands[i][0] = i * 2;\n                board.playerHands[i][1] = i * 2 + 1;\n            }\n        } else if (board.stage == GameStage.Flop) {\n            board.communityCards = new uint256[](5);\n            board.communityCards[0] = len * 2;\n            board.communityCards[1] = len * 2 + 1;\n            board.communityCards[2] = len * 2 + 2;\n        }\n        // else if (board.stage == GameStage.Turn) {\n        //     board.communityCards[3] = len * 2 + 3;\n        // }\n        // else if (board.stage == GameStage.River) {\n        //     board.communityCards[4] = len * 2 + 4;\n        // }\n    }\n\n    function _performBetWithAmount(BetType betType, uint256 amount)\n        internal\n        checkExist\n        checkTurn\n    {\n        require(board.stage == GameStage.PreFlopBet, \"can't be now\");\n        uint256 playerIndex = playerIndexesMap[msg.sender];\n\n        if (betType == BetType.Call) {\n            require(canCall(msg.sender, amount), \"cannot call\");\n            require(\n                board.playerStacks[playerIndex] >= amount,\n                \"insufficient amount\"\n            );\n            board.playerStacks[playerIndex] -= amount;\n            board.playerBets[playerIndex] += amount;\n            board.potSize += amount;\n        } else if (betType == BetType.Raise) {\n            require(canRaise(msg.sender, amount), \"cannot raise\");\n            board.playerStacks[playerIndex] -= amount;\n            board.playerBets[playerIndex] += amount;\n            board.potSize += amount;\n        } else if (betType == BetType.Check) {\n            require(canCheck(msg.sender), \"cannot raise\");\n            // nothing happens when check\n        } else if (betType == BetType.Fold) {\n            require(canFold(msg.sender), \"cannot fold\");\n            playerInPotsMap[msg.sender] = false;\n            board.playerInPots[playerIndex] = false;\n            if(_tryAnnounceWinnerDirectly()) {\n                return;\n            }\n        }\n        // play is done for this round\n        board.playersDoneForCurrentStage[playerIndex] = true;\n        _moveToTheNext();\n    }\n\n    function _performBet(BetType betType) internal {\n        _performBetWithAmount(betType, 0);\n    }\n\n    function _provideRevealProof(RevealProof calldata proof) internal {\n        require(verifier != address(0), \"empty verifier\");\n        require(\n            Verifier(verifier).verifyRevealAndSave(proof),\n            \"verification failed\"\n        );\n    }\n\n    function _clearMappings() internal {\n        address[] storage addrs = board.playerAddresses;\n        for (uint256 i = 0; i < addrs.length; ++i) {\n            delete playerInPotsMap[addrs[i]];\n            delete playerIndexesMap[addrs[i]];\n        }\n    }\n\n    // if there is only one player left, announce winner directly\n    function _tryAnnounceWinnerDirectly() internal returns (bool hasWinner) {\n        uint256 stillInPot;\n        uint256 winnerIndex;\n        for (uint256 i = 0; i < board.playerInPots.length; ++i) {\n            if(board.playerInPots[i]) {\n                stillInPot++;\n                winnerIndex = i;\n            }\n        }\n        if (stillInPot == 1) {\n            board.winner = board.playerAddresses[winnerIndex];\n            board.stage = GameStage.Ended;\n            board.playerStacks[winnerIndex] += board.potSize; \n            board.potSize = 0;\n            hasWinner = true;\n        }\n    }\n}\n"
    },
    "contracts/v2/GameUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BoardManagerStorage.sol\";\n\ncontract GameUtils {\n    uint256 public immutable CARD_NUM = 52;\n\n    function createInitialCards()\n        internal\n        pure\n        returns (uint256[] memory cards)\n    {\n        cards = new uint256[](CARD_NUM);\n        for (uint256 i = 0; i < CARD_NUM; ++i) {\n            cards[i] = i + 1;\n        }\n        return cards;\n    }\n\n    function getCardInfo(uint256 val) public pure returns (CardInfo memory) {\n        return CardInfo({rank: Rank(val / 13), value: val % 13});\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}